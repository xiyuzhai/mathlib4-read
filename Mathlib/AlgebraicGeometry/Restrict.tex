\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{geometry}
\geometry{margin=1in}

% Define colors for Lean syntax highlighting
\definecolor{leanKeyword}{RGB}{0, 0, 255}       % Blue for keywords
\definecolor{leanType}{RGB}{139, 0, 139}        % Dark magenta for types
\definecolor{leanString}{RGB}{0, 128, 0}        % Green for strings
\definecolor{leanComment}{RGB}{128, 128, 128}   % Gray for comments
\definecolor{leanDefinition}{RGB}{255, 140, 0}  % Dark orange for definitions
\definecolor{leanAttribute}{RGB}{255, 20, 147}  % Deep pink for attributes
\definecolor{leanBackground}{RGB}{250, 250, 250} % Light gray background

% Define Lean language for listings
\lstdefinelanguage{Lean}{
  % Keywords
  morekeywords=[1]{def, theorem, lemma, instance, class, structure, inductive,
    axiom, constant, variable, namespace, section, noncomputable, protected,
    private, abbrev, example, open, attribute, local, mutual, by, where,
    extends, deriving, end, import, prelude, theory, with, without, using,
    match, if, then, else, fun, have, show, from, let, in, do, begin, calc},
  % Types and Type constructors
  morekeywords=[2]{Type, Prop, Sort, Nat, Int, Bool, String, Char, List,
    Option, Unit, Prod, Sum, Sigma, Subtype, Set, Scheme, CommRingCat,
    AffineScheme, Opens, IsAffine, IsAffineOpen, Spec, Category, Functor,
    Iso, IsIso, CompactSpace, IsCompact, IsOpenImmersion, Equiv, Hom,
    pullback, PullbackCone, OpenCover, isOpenEmbedding, homOfLE},
  % Tactics (if they appear)
  morekeywords=[3]{simp, rfl, exact, apply, intro, cases, induction, refl,
    constructor, assumption, contradiction, trivial, sorry, admit, rw,
    convert, infer_instance, ext, rintro, obtain, refine, dsimp},
  % Sensitive
  sensitive=true,
  % Comments
  morecomment=[l]{--},
  morecomment=[n]{/-}{-/},
  % Strings
  morestring=[b]",
  % Style
  keywordstyle=[1]\color{leanKeyword}\bfseries,
  keywordstyle=[2]\color{leanType}\bfseries,
  keywordstyle=[3]\color{leanDefinition}\itshape,
  commentstyle=\color{leanComment}\itshape,
  stringstyle=\color{leanString},
  % Highlight attributes
  moredelim=[is][\color{leanAttribute}]{@[}{]},
  moredelim=[is][\color{leanAttribute}]{\#[}{]},
}

\lstset{
  language=Lean,
  basicstyle=\ttfamily\small,
  backgroundcolor=\color{leanBackground},
  breaklines=true,
  frame=single,
  framerule=0.5pt,
  rulecolor=\color{gray!30},
  numbers=left,
  numberstyle=\tiny\color{gray},
  numbersep=5pt,
  showstringspaces=false,
  captionpos=b,
  xleftmargin=10pt,
  framexleftmargin=10pt,
  % Unicode replacements for mathematical symbols
  literate={Œì}{{$\Gamma$}}1
           {‚ä§}{{$\top$}}1
           {‚ü∂}{{$\to$}}2
           {‚âÖ}{{$\cong$}}1
           {‚äÜ}{{$\subseteq$}}1
           {‚®Ü}{{$\bigsqcup$}}1
           {‚àà}{{$\in$}}1
           {‚àÉ}{{$\exists$}}1
           {‚àß}{{$\land$}}1
           {‚Åª¬π·µÅ}{{$^{-1}U$}}3
           {‚Åª¬π}{{$^{-1}$}}2
           {‚â´}{{>>}}1
           {‚â§}{{$\leq$}}1
           {·µí·µñ}{{$^{op}$}}2
           {‚•§}{{$\Rightarrow$}}2
           {‚âå}{{$\simeq$}}1
           {‚ãô}{{$\ggg$}}1
           {‚àÄ}{{$\forall$}}1
           {‚Üë}{{$\uparrow$}}1
           {ùí∞}{{$\mathcal{U}$}}1
           {ùüô}{{$\mathbb{1}$}}1
           {''·µÅ}{{''U}}2
           {‚â™‚â´}{{$\ll\gg$}}2
           {Œπ}{{$\iota$}}1
           {‚Üí}{{$\to$}}1
           {·µÅ}{{U}}1
           {:=}{{$\mathrel{:=}$}}2
           {√ó}{{$\times$}}1
           {‚ß∏}{{$/\!/$}}1
           {‚Üî}{{$\leftrightarrow$}}1
           {‚ü®}{{$\langle$}}1
           {‚ü©}{{$\rangle$}}1
           {Œ±}{{$\alpha$}}1
           {Œ≤}{{$\beta$}}1
           {Œ≥}{{$\gamma$}}1
           {Œ¥}{{$\delta$}}1
           {Œµ}{{$\varepsilon$}}1
           {Œª}{{$\lambda$}}1
           {Œº}{{$\mu$}}1
           {œÉ}{{$\sigma$}}1
           {œÑ}{{$\tau$}}1
           {œÜ}{{$\varphi$}}1
           {œà}{{$\psi$}}1
           {œâ}{{$\omega$}}1
           {‚àû}{{$\infty$}}1
           {‚àÇ}{{$\partial$}}1
           {‚àá}{{$\nabla$}}1
           {‚à£}{{$\mid$}}1
}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{instance}{Instance}

\title{Restriction of Schemes and Morphisms in Mathlib4\\
\large A Companion to \texttt{Restrict.lean}}
\author{}
\date{}

\begin{document}
\maketitle

\section{Introduction}

This document provides a natural language companion to the \texttt{Restrict.lean} file in Mathlib4. The file develops the theory of restricting schemes to open subsets and restricting morphisms accordingly. This is fundamental to the local nature of algebraic geometry, where properties are often studied by restricting to smaller open sets.

\section{Open Subsets as Schemes}

\subsection{Coercion to Schemes}

\begin{lstlisting}
@[coe]
def toScheme {X : Scheme.{u}} (U : X.Opens) : Scheme.{u} :=
  X.restrict U.isOpenEmbedding

instance : CoeOut X.Opens Scheme := ‚ü®toScheme‚ü©
\end{lstlisting}

\textbf{Natural Language:} Every open subset $U$ of a scheme $X$ can be viewed as a scheme in its own right through the restriction construction. This creates a coercion that allows us to treat opens as schemes directly.

\subsection{The Inclusion Morphism}

\begin{lstlisting}
def Œπ : ‚ÜëU ‚ü∂ X := X.ofRestrict _
\end{lstlisting}

\textbf{Natural Language:} For each open subset $U \subseteq X$, there is a canonical inclusion morphism $\iota: U \to X$ that embeds $U$ as an open subscheme of $X$.

\subsection{Open Immersion Property}

\begin{lstlisting}
instance : IsOpenImmersion U.Œπ
\end{lstlisting}

\textbf{Natural Language:} The inclusion morphism $U \to X$ is an open immersion, meaning it identifies $U$ with its image as an open subset and preserves the scheme structure.

\section{Presheaf Properties}

\subsection{Presheaf Objects}

\begin{lstlisting}
lemma toScheme_presheaf_obj (V) : Œì(U, V) = Œì(X, U.Œπ ''·µÅ V)
\end{lstlisting}

\textbf{Natural Language:} Sections over an open set $V$ in the restricted scheme $U$ correspond exactly to sections over the image $U.Œπ(V)$ in the original scheme $X$.

\subsection{Presheaf Maps}

\begin{lstlisting}
@[simp]
lemma toScheme_presheaf_map {V W} (i : V ‚ü∂ W) :
    U.toScheme.presheaf.map i = X.presheaf.map (U.Œπ.opensFunctor.map i.unop).op
\end{lstlisting}

\textbf{Natural Language:} Restriction maps in the presheaf on $U$ are obtained by pushing forward along $\iota$ to get restriction maps in the presheaf on $X$.

\section{Application Maps}

\subsection{Basic Application}

\begin{lstlisting}
@[simp]
lemma Œπ_app (V) : U.Œπ.app V = X.presheaf.map
    (homOfLE (x := U.Œπ ''·µÅ U.Œπ ‚Åª¬π·µÅ V) (Set.image_preimage_subset _ _)).op
\end{lstlisting}

\textbf{Natural Language:} The application of $\iota$ to sections is given by the natural restriction map in $X$'s presheaf.

\subsection{Top Application}

\begin{lstlisting}
@[simp]
lemma Œπ_appTop :
    U.Œπ.appTop = X.presheaf.map (homOfLE (x := U.Œπ ''·µÅ ‚ä§) le_top).op
\end{lstlisting}

\textbf{Natural Language:} Taking global sections of $U$ corresponds to taking sections of $X$ over the image of $U$.

\section{Range Properties}

\subsection{Opens Range}

\begin{lstlisting}
@[simp]
lemma opensRange_Œπ : U.Œπ.opensRange = U
\end{lstlisting}

\textbf{Natural Language:} The image of $\iota$ as an open subset is exactly $U$ itself.

\subsection{Topological Range}

\begin{lstlisting}
@[simp]
lemma range_Œπ : Set.range U.Œπ.base = U
\end{lstlisting}

\textbf{Natural Language:} The image of the underlying continuous map is exactly the subset $U \subseteq X$.

\section{Global Sections Isomorphism}

\subsection{Top Isomorphism}

\begin{lstlisting}
@[simps!]
def topIso : Œì(U, ‚ä§) ‚âÖ Œì(X, U) :=
  X.presheaf.mapIso (eqToIso U.Œπ_image_top.symm).op
\end{lstlisting}

\textbf{Natural Language:} The global sections of the restricted scheme $U$ are naturally isomorphic to the sections of $X$ over the open set $U$. This establishes the fundamental relationship between restriction and sections.

\section{Stalks}

\subsection{Stalk Isomorphism}

\begin{lstlisting}
def stalkIso {X : Scheme.{u}} (U : X.Opens) (x : U) :
    U.toScheme.presheaf.stalk x ‚âÖ X.presheaf.stalk x.1
\end{lstlisting}

\textbf{Natural Language:} The stalk of the structure sheaf of $U$ at a point $x$ is naturally isomorphic to the stalk of $X$'s structure sheaf at the same point. This shows that local properties are preserved under restriction.

\subsection{Germ Compatibility}

\begin{lstlisting}
@[reassoc (attr := simp)]
lemma germ_stalkIso_hom {X : Scheme.{u}} (U : X.Opens)
    {V : U.toScheme.Opens} (x : U) (hx : x ‚àà V) :
      U.toScheme.presheaf.germ V x hx ‚â´ (U.stalkIso x).hom =
        X.presheaf.germ (U.Œπ ''·µÅ V) x.1 ‚ü®x, hx, rfl‚ü©
\end{lstlisting}

\textbf{Natural Language:} Germs (local sections) behave compatibly with the stalk isomorphism, ensuring that the restriction preserves all local algebraic structure.

\section{Restriction Functors and Equivalences}

\subsection{Opens Restriction}

\begin{lstlisting}
@[simps!]
def opensRestrict :
    Scheme.Opens U ‚âÉ { V : X.Opens // V ‚â§ U }
\end{lstlisting}

\textbf{Natural Language:} Open subsets of the restricted scheme $U$ correspond bijectively to open subsets of $X$ that are contained in $U$.

\subsection{Restrict Functor}

\begin{lstlisting}
@[simps! obj_left obj_hom map_left]
def Scheme.restrictFunctor : X.Opens ‚•§ Over X where
  obj U := Over.mk U.Œπ
  map {U V} i := Over.homMk (X.homOfLE i.le) (by simp)
\end{lstlisting}

\textbf{Natural Language:} There is a functor from the category of opens of $X$ to schemes over $X$, sending each open $U$ to the restricted scheme $U \to X$.

\section{Morphisms Between Opens}

\subsection{Inclusion of Smaller Opens}

\begin{lstlisting}
protected noncomputable
def Scheme.homOfLE (X : Scheme.{u}) {U V : X.Opens} (e : U ‚â§ V) : (U : Scheme.{u}) ‚ü∂ V
\end{lstlisting}

\textbf{Natural Language:} If $U \subseteq V$ are open subsets of $X$, there is a natural morphism from the scheme $U$ to the scheme $V$.

\subsection{Compatibility with Inclusion}

\begin{lstlisting}
@[reassoc (attr := simp)]
lemma Scheme.homOfLE_Œπ (X : Scheme.{u}) {U V : X.Opens} (e : U ‚â§ V) :
    X.homOfLE e ‚â´ V.Œπ = U.Œπ
\end{lstlisting}

\textbf{Natural Language:} The composition $U \to V \to X$ equals the direct inclusion $U \to X$.

\section{Basic Opens and Localizations}

\subsection{Basic Open Mapping}

\begin{lstlisting}
lemma Scheme.map_basicOpen (r : Œì(U, ‚ä§)) :
    U.Œπ ''·µÅ U.toScheme.basicOpen r = X.basicOpen
      (X.presheaf.map (eqToHom U.isOpenEmbedding_obj_top.symm).op r)
\end{lstlisting}

\textbf{Natural Language:} The image under $\iota$ of a basic open $D(r)$ in $U$ equals a basic open in $X$ determined by the corresponding section.

\subsection{Basic Open Isomorphism to Localization}

\begin{lstlisting}
def basicOpenIsoSpecAway {R : CommRingCat.{u}} (f : R) :
    Scheme.Opens.toScheme (X := Spec R) (PrimeSpectrum.basicOpen f) ‚âÖ Spec(Localization.Away f)
\end{lstlisting}

\textbf{Natural Language:} For an affine scheme $\mathrm{Spec}(R)$, the basic open $D(f)$ is isomorphic to $\mathrm{Spec}(R[1/f])$, establishing the connection between geometric opens and ring-theoretic localizations.

\section{Morphism Restriction}

\subsection{Pullback-Restriction Isomorphism}

\begin{lstlisting}
def pullbackRestrictIsoRestrict {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (U : Y.Opens) :
    pullback f (U.Œπ) ‚âÖ f ‚Åª¬π·µÅ U
\end{lstlisting}

\textbf{Natural Language:} The pullback of a morphism $f: X \to Y$ along the inclusion $U \to Y$ is isomorphic to the restriction of $X$ to the preimage $f^{-1}(U)$.

\subsection{Morphism Restriction Definition}

\begin{lstlisting}
def morphismRestrict {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (U : Y.Opens) : (f ‚Åª¬π·µÅ U).toScheme ‚ü∂ U :=
  (pullbackRestrictIsoRestrict f U).inv ‚â´ pullback.snd _ _

infixl:85 " ‚à£_ " => morphismRestrict
\end{lstlisting}

\textbf{Natural Language:} Given a morphism $f: X \to Y$ and an open $U \subseteq Y$, we can restrict $f$ to get a morphism $f|_U: f^{-1}(U) \to U$. This uses the notation $f \mid_U$.

\section{Properties of Morphism Restriction}

\subsection{Compatibility with Inclusions}

\begin{lstlisting}
@[reassoc (attr := simp)]
theorem morphismRestrict_Œπ {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (U : Y.Opens) :
    (f ‚à£_ U) ‚â´ U.Œπ = (f ‚Åª¬π·µÅ U).Œπ ‚â´ f
\end{lstlisting}

\textbf{Natural Language:} The restricted morphism is compatible with the inclusion maps in the sense that the diagram commutes.

\subsection{Identity Restriction}

\begin{lstlisting}
@[simp]
lemma morphismRestrict_id {X : Scheme.{u}} (U : X.Opens) : ùüô X ‚à£_ U = ùüô _ := by
  rw [‚Üê cancel_mono U.Œπ, morphismRestrict_Œπ, Category.comp_id, Category.id_comp]
\end{lstlisting}

\textbf{Natural Language:} Restricting the identity morphism gives the identity on the restricted scheme.

\subsection{Composition Property}

\begin{lstlisting}
theorem morphismRestrict_comp {X Y Z : Scheme.{u}} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (U : Opens Z) :
    (f ‚â´ g) ‚à£_ U = f ‚à£_ g ‚Åª¬π·µÅ U ‚â´ g ‚à£_ U
\end{lstlisting}

\textbf{Natural Language:} Restricting a composition of morphisms equals the composition of the appropriate restrictions.

\section{Base Change Properties}

\subsection{Continuous Map Base}

\begin{lstlisting}
theorem morphismRestrict_base {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (U : Y.Opens) :
    ‚áë(f ‚à£_ U).base = U.1.restrictPreimage f.base
\end{lstlisting}

\textbf{Natural Language:} The underlying continuous map of the restricted morphism is the restriction of the original continuous map to the appropriate preimage.

\subsection{Pullback Isomorphism}

\begin{lstlisting}
theorem isPullback_morphismRestrict {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (U : Y.Opens) :
    IsPullback (f ‚à£_ U) (f ‚Åª¬π·µÅ U).Œπ U.Œπ f
\end{lstlisting}

\textbf{Natural Language:} The restriction construction gives a genuine pullback square, confirming that it captures the correct universal property.

\section{Stalk Maps and Localization}

\subsection{Stalk Map Compatibility}

\begin{lstlisting}
def morphismRestrictStalkMap {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (U : Y.Opens) (x) :
    Arrow.mk ((f ‚à£_ U).stalkMap x) ‚âÖ Arrow.mk (f.stalkMap x.1)
\end{lstlisting}

\textbf{Natural Language:} The stalk map of a restricted morphism is naturally isomorphic to the stalk map of the original morphism, showing that local algebraic properties are preserved.

\section{Advanced Restriction Constructions}

\subsection{Double Restriction}

\begin{lstlisting}
def morphismRestrictRestrict {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (U : Y.Opens) (V : U.toScheme.Opens) :
    Arrow.mk (f ‚à£_ U ‚à£_ V) ‚âÖ Arrow.mk (f ‚à£_ U.Œπ ''·µÅ V)
\end{lstlisting}

\textbf{Natural Language:} Restricting twice is isomorphic to a single restriction to the appropriate open subset.

\subsection{Basic Open Restriction}

\begin{lstlisting}
def morphismRestrictRestrictBasicOpen {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (U : Y.Opens) (r : Œì(Y, U)) :
    Arrow.mk (f ‚à£_ U ‚à£_ U.toScheme.basicOpen (Y.presheaf.map (eqToHom U.isOpenEmbedding_obj_top).op r)) ‚âÖ
      Arrow.mk (f ‚à£_ Y.basicOpen r)
\end{lstlisting}

\textbf{Natural Language:} Restricting first to an open $U$ and then to a basic open determined by a section on $U$ is isomorphic to restricting directly to the corresponding basic open in $Y$.

\section{Applications to Covers}

\subsection{Open Cover Restriction}

\begin{lstlisting}
@[simps! J obj map]
noncomputable
def Scheme.OpenCover.restrict {X : Scheme.{u}} (ùí∞ : X.OpenCover) (U : Opens X) :
    U.toScheme.OpenCover
\end{lstlisting}

\textbf{Natural Language:} Given an open cover of $X$, we can restrict it to get an open cover of any open subset $U \subseteq X$.

\section{Conclusion}

The restriction theory developed in \texttt{Restrict.lean} provides:

\subsection{Foundational Results}
\begin{itemize}
\item Every open subset naturally carries a scheme structure
\item Inclusion morphisms are open immersions
\item Local properties (stalks, germs) are preserved under restriction
\end{itemize}

\subsection{Functorial Properties}
\begin{itemize}
\item Restriction gives functors between appropriate categories
\item Global sections of restricted schemes relate naturally to sections on opens
\item Morphisms can be restricted in a way that preserves composition and identities
\end{itemize}

\subsection{Connections to Commutative Algebra}
\begin{itemize}
\item Basic opens in affine schemes correspond to localizations
\item Stalks of restricted schemes are unchanged
\item Restriction preserves the local ring structure
\end{itemize}

\subsection{Geometric Applications}
\begin{itemize}
\item Provides the foundation for studying local properties of schemes
\item Enables the use of open covers to reduce global problems to local ones
\item Essential for constructions like gluing and descent theory
\end{itemize}

This restriction theory is fundamental to algebraic geometry, enabling the systematic study of local properties and the construction of schemes via gluing local pieces.

\end{document}