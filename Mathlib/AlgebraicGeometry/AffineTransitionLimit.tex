\documentclass{article}
\input{unicode_preamble}

\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{geometry}
\geometry{margin=1in}

% Define colors for Lean syntax highlighting
\definecolor{leanKeyword}{RGB}{0, 0, 255}       % Blue for keywords
\definecolor{leanType}{RGB}{139, 0, 139}        % Dark magenta for types
\definecolor{leanString}{RGB}{0, 128, 0}        % Green for strings
\definecolor{leanComment}{RGB}{128, 128, 128}   % Gray for comments
\definecolor{leanDefinition}{RGB}{255, 140, 0}  % Dark orange for definitions

% Configure listings for Lean
\lstdefinelanguage{Lean}{
    keywords={def, theorem, lemma, example, axiom, class, instance, inductive, structure,
              variable, namespace, open, import, export, section, end, if, then, else,
              match, with, fun, let, have, show, by, where, do, return, for, in,
              variable, universe, noncomputable, partial, mutual, protected, private,
              unsafe, opaque, @[simp], @[inline], @[reducible], @[irreducible],
              attribute, set_option, notation, infixl, infixr, prefix, postfix,
              scoped, local, macro, syntax, elab, deriving, extends, mk},
    morekeys={Type, Prop, Sort, Nat, Int, Real, Bool, true, false, Unit, 
              List, Array, Option, some, none, Sum, Prod, Sigma, Pi,
              and, or, not, iff, exists, forall},
    sensitive=true,
    morecomment=[l]{--},
    morecomment=[s]{/-}{-/},
    morestring=[b]",
    morestring=[b]',
}

\lstset{
    language=Lean,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{leanKeyword}\bfseries,
    commentstyle=\color{leanComment}\itshape,
    stringstyle=\color{leanString},
    numberstyle=\tiny\color{gray},
    numbers=left,
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{white},
    frame=single,
    rulecolor=\color{black!30},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=2,
    captionpos=b,
    showstringspaces=false,
    literate={
        {Î±}{{$\alpha$}}1 {Î²}{{$\beta$}}1 {Î³}{{$\gamma$}}1 {Î´}{{$\delta$}}1
        {Îµ}{{$\varepsilon$}}1 {Î¶}{{$\zeta$}}1 {Î·}{{$\eta$}}1 {Î¸}{{$\theta$}}1
        {Î¹}{{$\iota$}}1 {Îº}{{$\kappa$}}1 {Î»}{{$\lambda$}}1 {Î¼}{{$\mu$}}1
        {Î½}{{$\nu$}}1 {Î¾}{{$\xi$}}1 {Ï€}{{$\pi$}}1 {Ï}{{$\rho$}}1
        {Ïƒ}{{$\sigma$}}1 {Ï„}{{$\tau$}}1 {Ï†}{{$\varphi$}}1 {Ï‡}{{$\chi$}}1
        {Ïˆ}{{$\psi$}}1 {Ï‰}{{$\omega$}}1 {Î“}{{$\Gamma$}}1 {Î”}{{$\Delta$}}1
        {Î˜}{{$\Theta$}}1 {Î›}{{$\Lambda$}}1 {Î£}{{$\Sigma$}}1 {Î¦}{{$\Phi$}}1
        {Î¨}{{$\Psi$}}1 {Î©}{{$\Omega$}}1
        {â†’}{{$\rightarrow$}}2 {â†}{{$\leftarrow$}}2 {âŸ¶}{{$\longrightarrow$}}2
        {â†”}{{$\leftrightarrow$}}2 {âŸ·}{{$\longleftrightarrow$}}2
        {â‰¤}{{$\leq$}}1 {â‰¥}{{$\geq$}}1 {â‰ }{{$\neq$}}1 {â‰ˆ}{{$\approx$}}1
        {â‰¡}{{$\equiv$}}1 {â‰…}{{$\cong$}}1 {â‰ƒ}{{$\simeq$}}1
        {âˆˆ}{{$\in$}}1 {âˆ‰}{{$\notin$}}1 {âŠ†}{{$\subseteq$}}1 {âŠ‡}{{$\supseteq$}}1
        {âŠ‚}{{$\subset$}}1 {âŠƒ}{{$\supset$}}1 {âˆª}{{$\cup$}}1 {âˆ©}{{$\cap$}}1
        {âˆ…}{{$\emptyset$}}1 {âˆ}{{$\infty$}}1 {âˆ‚}{{$\partial$}}1
        {âˆ€}{{$\forall$}}1 {âˆƒ}{{$\exists$}}1 {âˆ§}{{$\land$}}1 {âˆ¨}{{$\lor$}}1
        {Â¬}{{$\neg$}}1 {âŠ¤}{{$\top$}}1 {âŠ¥}{{$\bot$}}1
        {Ã—}{{$\times$}}1 {Â·}{{$\cdot$}}1 {âˆ˜}{{$\circ$}}1
        {âŠ—}{{$\otimes$}}1 {âŠ•}{{$\oplus$}}1 {âŠ™}{{$\odot$}}1
        {âˆ‘}{{$\sum$}}1 {âˆ}{{$\prod$}}1 {âˆ«}{{$\int$}}1
        {â‚€}{{$_0$}}1 {â‚}{{$_1$}}1 {â‚‚}{{$_2$}}1 {â‚ƒ}{{$_3$}}1 {â‚„}{{$_4$}}1
        {â‚…}{{$_5$}}1 {â‚†}{{$_6$}}1 {â‚‡}{{$_7$}}1 {â‚ˆ}{{$_8$}}1 {â‚‰}{{$_9$}}1
        {â‚™}{{$_n$}}1 {â‚˜}{{$_m$}}1 {áµ¢}{{$_i$}}1 {â±¼}{{$_j$}}1
        {â°}{{$^0$}}1 {Â¹}{{$^1$}}1 {Â²}{{$^2$}}1 {Â³}{{$^3$}}1 {â´}{{$^4$}}1
        {âµ}{{$^5$}}1 {â¶}{{$^6$}}1 {â·}{{$^7$}}1 {â¸}{{$^8$}}1 {â¹}{{$^9$}}1
        {â¿}{{$^n$}}1 {áµ}{{$^m$}}1 {â±}{{$^i$}}1
        {â„•}{{$\mathbb{N}$}}1 {â„¤}{{$\mathbb{Z}$}}1 {â„š}{{$\mathbb{Q}$}}1
        {â„}{{$\mathbb{R}$}}1 {â„‚}{{$\mathbb{C}$}}1
        {ğ’°}{{$\mathcal{U}$}}1 {ğ’±}{{$\mathcal{V}$}}1 {ğ’²}{{$\mathcal{W}$}}1
        {ğ’³}{{$\mathcal{X}$}}1 {ğ’´}{{$\mathcal{Y}$}}1 {ğ’µ}{{$\mathcal{Z}$}}1
        {ğ”¸}{{$\mathbb{A}$}}1 {ğ”¹}{{$\mathbb{B}$}}1 {ğ”½}{{$\mathbb{F}$}}1
        {ğ•‚}{{$\mathbb{K}$}}1 {ğ•Š}{{$\mathbb{S}$}}1
        {âŸ¨}{{$\langle$}}1 {âŸ©}{{$\rangle$}}1 {âŒŠ}{{$\lfloor$}}1 {âŒ‹}{{$\rfloor$}}1
        {âŒˆ}{{$\lceil$}}1 {âŒ‰}{{$\rceil$}}1
        {â»Â¹}{{$^{-1}$}}2 {â–¸}{{$\triangleright$}}1
    }
}

\title{Lean 4 Code: AffineTransitionLimit}
\author{Mathlib4}
\date{\today}

\begin{document}
\maketitle

\section{Source Code}

The following is the Lean 4 source code from \texttt{AffineTransitionLimit.lean}:

\begin{lstlisting}[language=Lean, caption={AffineTransitionLimit.lean}]
/-
Copyright (c) 2025 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang
-/
import Mathlib.AlgebraicGeometry.IdealSheaf.Functorial
import Mathlib.AlgebraicGeometry.Morphisms.Separated
import Mathlib.CategoryTheory.Filtered.Final

/-!

# Inverse limits of schemes with affine transition maps

In this file, we develop API for inverse limits of schemes with affine transition maps,
following EGA IV 8 and https://stacks.math.columbia.edu/tag/01YT.

-/

universe uI u

open AlgebraicGeometry CategoryTheory Limits

-- We refrain from considering diagrams in the over category since inverse limits in the over
-- category is isomorphic to limits in `Scheme`. Instead we use `D âŸ¶ (Functor.const I).obj S` to
-- say that the diagram is over the base scheme `S`.
variable {I : Type u} [Category.{u} I] {S X : Scheme.{u}} (D : I â¥¤ Scheme.{u})
  (t : D âŸ¶ (Functor.const I).obj S) (f : X âŸ¶ S) (c : Cone D) (hc : IsLimit c)

include hc in
/--
Suppose we have a cofiltered diagram of nonempty quasi-compact schemes,
whose transition maps are affine. Then the limit is also nonempty.
-/
@[stacks 01Z2]
lemma Scheme.nonempty_of_isLimit [IsCofilteredOrEmpty I]
    [âˆ€ {i j} (f : i âŸ¶ j), IsAffineHom (D.map f)] [âˆ€ i, Nonempty (D.obj i)]
    [âˆ€ i, CompactSpace (D.obj i)] :
    Nonempty c.pt := by
  classical
  cases isEmpty_or_nonempty I
  Â· have e := (isLimitEquivIsTerminalOfIsEmpty _ _ hc).uniqueUpToIso specULiftZIsTerminal
    exact Nonempty.map e.inv.base inferInstance
  Â· have i := Nonempty.some â€¹Nonempty Iâ€º
    have : IsCofiltered I := âŸ¨âŸ©
    let ğ’° := (D.obj i).affineCover.finiteSubcover
    have (i' : _) : IsAffine (ğ’°.obj i') := inferInstanceAs (IsAffine (Spec _))
    obtain âŸ¨j, HâŸ© :
        âˆƒ j : ğ’°.J, âˆ€ {i'} (f : i' âŸ¶ i), Nonempty ((ğ’°.pullbackCover (D.map f)).obj j) := by
      simp_rw [â† not_isEmpty_iff]
      by_contra! H
      choose i' f hf using H
      let g (j) := IsCofiltered.infTo (insert i (Finset.univ.image i'))
        (Finset.univ.image fun j : ğ’°.J â†¦ âŸ¨_, _, by simp, by simp, f jâŸ©) (X := j)
      have (j : ğ’°.J) : IsEmpty ((ğ’°.pullbackCover (D.map (g i (by simp)))).obj j) := by
        let F : (ğ’°.pullbackCover (D.map (g i (by simp)))).obj j âŸ¶
            (ğ’°.pullbackCover (D.map (f j))).obj j :=
          pullback.map _ _ _ _ (D.map (g _ (by simp))) (ğŸ™ _) (ğŸ™ _) (by
            rw [â† D.map_comp, IsCofiltered.infTo_commutes]
            Â· simp [g]
            Â· simp
            Â· exact Finset.mem_image_of_mem _ (Finset.mem_univ _)) (by simp)
        exact Function.isEmpty F.base
      obtain âŸ¨x, -âŸ© :=
        (ğ’°.pullbackCover (D.map (g i (by simp)))).covers (Nonempty.some inferInstance)
      exact (this _).elim x
    let F := Over.post D â‹™ Over.pullback (ğ’°.map j) â‹™ Over.forget _
    have (i' : _) : IsAffine (F.obj i') :=
      have : IsAffineHom (pullback.snd (D.map i'.hom) (ğ’°.map j)) :=
        MorphismProperty.pullback_snd _ _ inferInstance
      isAffine_of_isAffineHom (pullback.snd (D.map i'.hom) (ğ’°.map j))
    have (i' : _) : Nonempty (F.obj i') := H i'.hom
    let e : F âŸ¶ (F â‹™ Scheme.Î“.rightOp) â‹™ Scheme.Spec := Functor.whiskerLeft F Î“Spec.adjunction.unit
    have (i : _) : IsIso (e.app i) := IsAffine.affine
    have : IsIso e := NatIso.isIso_of_isIso_app e
    let c' : LimitCone F := âŸ¨_, (IsLimit.postcomposeInvEquiv (asIso e) _).symm
      (isLimitOfPreserves Scheme.Spec (limit.isLimit (F â‹™ Scheme.Î“.rightOp)))âŸ©
    have : Nonempty c'.1.pt := by
      apply (config := { allowSynthFailures := true }) PrimeSpectrum.instNonemptyOfNontrivial
      have (i' : _) : Nontrivial ((F â‹™ Scheme.Î“.rightOp).leftOp.obj i') := by
        apply (config := { allowSynthFailures := true }) Scheme.component_nontrivial
        simp
      exact CommRingCat.FilteredColimits.nontrivial
        (isColimitCoconeLeftOpOfCone _ (limit.isLimit (F â‹™ Scheme.Î“.rightOp)))
    let Î± : F âŸ¶ Over.forget _ â‹™ D := Functor.whiskerRight
      (Functor.whiskerLeft (Over.post D) (Over.mapPullbackAdj (ğ’°.map j)).counit) (Over.forget _)
    exact this.map (((Functor.Initial.isLimitWhiskerEquiv (Over.forget i) c).symm hc).lift
        ((Cones.postcompose Î±).obj c'.1)).base

include hc in
open Scheme.IdealSheafData in
/--
Suppose we have a cofiltered diagram of schemes whose transition maps are affine. The limit of
a family of compatible nonempty quasicompact closed sets in the diagram is also nonempty.
-/
lemma exists_mem_of_isClosed_of_nonempty
    [IsCofilteredOrEmpty I]
    [âˆ€ {i j} (f : i âŸ¶ j), IsAffineHom (D.map f)]
    (Z : âˆ€ (i : I), Set (D.obj i))
    (hZc : âˆ€ (i : I), IsClosed (Z i))
    (hZne : âˆ€ i, (Z i).Nonempty)
    (hZcpt : âˆ€ i, IsCompact (Z i))
    (hmapsTo : âˆ€ {i i' : I} (f : i âŸ¶ i'), Set.MapsTo (D.map f).base (Z i) (Z i')) :
    âˆƒ (s : c.pt), âˆ€ i, (c.Ï€.app i).base s âˆˆ Z i := by
  let D' : I â¥¤ Scheme :=
  { obj i := (vanishingIdeal âŸ¨Z i, hZc iâŸ©).subscheme
    map {X Y} f := subschemeMap _ _ (D.map f) (by
      rw [map_vanishingIdeal, â† le_support_iff_le_vanishingIdeal]
      simpa [(hZc _).closure_subset_iff] using (hmapsTo f).subset_preimage)
    map_id _ := by simp [â† cancel_mono (subschemeÎ¹ _)]
    map_comp _ _ := by simp [â† cancel_mono (subschemeÎ¹ _)] }
  let Î¹ : D' âŸ¶ D := { app i := subschemeÎ¹ _, naturality _ _ _ := by simp [D'] }
  haveI {i j} (f : i âŸ¶ j) : IsAffineHom (D'.map f) := by
    suffices IsAffineHom (D'.map f â‰« Î¹.app j) from .of_comp _ (Î¹.app j)
    simp only [subschemeMap_subschemeÎ¹, D', Î¹]
    infer_instance
  haveI _ (i) : Nonempty (D'.obj i) := Set.nonempty_coe_sort.mpr (hZne i)
  haveI _ (i) : CompactSpace (D'.obj i) := isCompact_iff_compactSpace.mp (hZcpt i)
  let c' : Cone D' :=
  { pt := (â¨† i, (vanishingIdeal âŸ¨Z i, hZc iâŸ©).comap (c.Ï€.app i)).subscheme
    Ï€ :=
    { app i := subschemeMap _ _ (c.Ï€.app i) (by simp [le_map_iff_comap_le, le_iSup_of_le i])
      naturality {i j} f := by simp [D', â† cancel_mono (subschemeÎ¹ _)] } }
  let hc' : IsLimit c' :=
  { lift s := IsClosedImmersion.lift (subschemeÎ¹ _) (hc.lift ((Cones.postcompose Î¹).obj s)) (by
      suffices âˆ€ i, vanishingIdeal âŸ¨Z i, hZc iâŸ© â‰¤ (s.Ï€.app i â‰« Î¹.app i).ker by
        simpa [â† le_map_iff_comap_le, â† Scheme.Hom.ker_comp]
      refine fun i â†¦ .trans ?_ (Scheme.Hom.le_ker_comp _ _)
      simp [Î¹])
    fac s i := by simp [â† cancel_mono (subschemeÎ¹ _), c', Î¹]
    uniq s m hm := by
      rw [â† cancel_mono (subschemeÎ¹ _)]
      refine hc.hom_ext fun i â†¦ ?_
      simp [Î¹, c', â† hm] }
  have : Nonempty (â¨† i, (vanishingIdeal âŸ¨Z i, hZc iâŸ©).comap (c.Ï€.app i)).support :=
    Scheme.nonempty_of_isLimit D' c' hc'
  simpa using this

include hc in
/--
A variant of `exists_mem_of_isClosed_of_nonempty` where the closed sets are only defined
for the objects over a given `j : I`.
-/
@[stacks 01Z3]
lemma exists_mem_of_isClosed_of_nonempty'
    [IsCofilteredOrEmpty I]
    [âˆ€ {i j} (f : i âŸ¶ j), IsAffineHom (D.map f)]
    {j : I}
    (Z : âˆ€ (i : I), (i âŸ¶ j) â†’ Set (D.obj i))
    (hZc : âˆ€ i hij, IsClosed (Z i hij))
    (hZne : âˆ€ i hij, (Z i hij).Nonempty)
    (hZcpt : âˆ€ i hij, IsCompact (Z i hij))
    (hstab : âˆ€ (i i' : I) (hi'i : i' âŸ¶ i) (hij : i âŸ¶ j),
      Set.MapsTo (D.map hi'i).base (Z i' (hi'i â‰« hij)) (Z i hij)) :
    âˆƒ (s : c.pt), âˆ€ i hij, (c.Ï€.app i).base s âˆˆ Z i hij := by
  have {iâ‚ iâ‚‚ : Over j} (f : iâ‚ âŸ¶ iâ‚‚) : IsAffineHom ((Over.forget j â‹™ D).map f) := by
    dsimp; infer_instance
  simpa [Over.forall_iff] using exists_mem_of_isClosed_of_nonempty (Over.forget j â‹™ D) _
    ((Functor.Initial.isLimitWhiskerEquiv (Over.forget j) c).symm hc)
    (fun i â†¦ Z i.left i.hom) (fun _ â†¦ hZc _ _)  (fun _ â†¦ hZne _ _)  (fun _ â†¦ hZcpt _ _)
    (fun {iâ‚ iâ‚‚} f â†¦ by dsimp; rw [â† Over.w f]; exact hstab ..)

\end{lstlisting}

\end{document}
