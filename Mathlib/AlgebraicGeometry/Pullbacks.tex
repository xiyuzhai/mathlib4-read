\documentclass{article}
\usepackage[utf8]{inputenc}
% Better Unicode support
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{textcomp}
\usepackage{newunicodechar}
\usepackage{stmaryrd}

% Define Unicode characters
\newunicodechar{↦}{\ensuremath{\mapsto}}
\newunicodechar{⟨}{\ensuremath{\langle}}
\newunicodechar{⟩}{\ensuremath{\rangle}}
\newunicodechar{‹}{\ensuremath{\langle}}
\newunicodechar{›}{\ensuremath{\rangle}}
\newunicodechar{→}{\ensuremath{\to}}
\newunicodechar{⟶}{\ensuremath{\longrightarrow}}
\newunicodechar{↪}{\ensuremath{\hookrightarrow}}
\newunicodechar{≅}{\ensuremath{\cong}}
\newunicodechar{≃}{\ensuremath{\simeq}}
\newunicodechar{⊆}{\ensuremath{\subseteq}}
\newunicodechar{⊇}{\ensuremath{\supseteq}}
\newunicodechar{∈}{\ensuremath{\in}}
\newunicodechar{∉}{\ensuremath{\notin}}
\newunicodechar{∃}{\ensuremath{\exists}}
\newunicodechar{∀}{\ensuremath{\forall}}
\newunicodechar{∧}{\ensuremath{\land}}
\newunicodechar{∨}{\ensuremath{\lor}}
\newunicodechar{≤}{\ensuremath{\leq}}
\newunicodechar{≥}{\ensuremath{\geq}}
\newunicodechar{≠}{\ensuremath{\neq}}
\newunicodechar{≡}{\ensuremath{\equiv}}
\newunicodechar{≈}{\ensuremath{\approx}}
\newunicodechar{∞}{\ensuremath{\infty}}
\newunicodechar{∅}{\ensuremath{\emptyset}}
\newunicodechar{∪}{\ensuremath{\cup}}
\newunicodechar{∩}{\ensuremath{\cap}}
\newunicodechar{×}{\ensuremath{\times}}
\newunicodechar{⊗}{\ensuremath{\otimes}}
\newunicodechar{⊕}{\ensuremath{\oplus}}
\newunicodechar{⊤}{\ensuremath{\top}}
\newunicodechar{⊥}{\ensuremath{\bot}}
\newunicodechar{∘}{\ensuremath{\circ}}
\newunicodechar{∂}{\ensuremath{\partial}}
\newunicodechar{∇}{\ensuremath{\nabla}}
\newunicodechar{∫}{\ensuremath{\int}}
\newunicodechar{∑}{\ensuremath{\sum}}
\newunicodechar{∏}{\ensuremath{\prod}}
\newunicodechar{⋯}{\ensuremath{\cdots}}
\newunicodechar{⨆}{\ensuremath{\bigsqcup}}
\newunicodechar{⧸}{\ensuremath{/}}
\newunicodechar{≫}{\ensuremath{\gg}}
\newunicodechar{≪}{\ensuremath{\ll}}
\newunicodechar{⥤}{\ensuremath{\Rightarrow}}
\newunicodechar{⋙}{\ensuremath{\ggg}}
\newunicodechar{≌}{\ensuremath{\fallingdotseq}}
\newunicodechar{↑}{\ensuremath{\uparrow}}
\newunicodechar{↓}{\ensuremath{\downarrow}}
\newunicodechar{⇒}{\ensuremath{\Rightarrow}}
\newunicodechar{⇐}{\ensuremath{\Leftarrow}}
\newunicodechar{⇔}{\ensuremath{\Leftrightarrow}}
\newunicodechar{↔}{\ensuremath{\leftrightarrow}}
\newunicodechar{⊢}{\ensuremath{\vdash}}
\newunicodechar{⊣}{\ensuremath{\dashv}}
\newunicodechar{⊓}{\ensuremath{\sqcap}}
\newunicodechar{⊔}{\ensuremath{\sqcup}}
\newunicodechar{⋮}{\ensuremath{\vdots}}
\newunicodechar{⋱}{\ensuremath{\ddots}}
\newunicodechar{√}{\ensuremath{\sqrt{}}}
\newunicodechar{∝}{\ensuremath{\propto}}
\newunicodechar{∼}{\ensuremath{\sim}}
\newunicodechar{≲}{\ensuremath{\lesssim}}
\newunicodechar{≳}{\ensuremath{\gtrsim}}
\newunicodechar{⊂}{\ensuremath{\subset}}
\newunicodechar{⊃}{\ensuremath{\supset}}
\newunicodechar{⊊}{\ensuremath{\subsetneq}}
\newunicodechar{⊋}{\ensuremath{\supsetneq}}
\newunicodechar{∖}{\ensuremath{\setminus}}
\newunicodechar{∣}{\ensuremath{\mid}}
\newunicodechar{∤}{\ensuremath{\nmid}}
\newunicodechar{∥}{\ensuremath{\parallel}}
\newunicodechar{∦}{\ensuremath{\nparallel}}
\newunicodechar{⊙}{\ensuremath{\odot}}
\newunicodechar{⊖}{\ensuremath{\ominus}}
\newunicodechar{⊘}{\ensuremath{\oslash}}
\newunicodechar{⊚}{\ensuremath{\circledcirc}}
\newunicodechar{⊛}{\ensuremath{\circledast}}
\newunicodechar{⊝}{\ensuremath{\circleddash}}
\newunicodechar{◯}{\ensuremath{\bigcirc}}
\newunicodechar{⬝}{\ensuremath{\cdot}}
\newunicodechar{▸}{\ensuremath{\blacktriangleright}}

% Greek letters
\newunicodechar{α}{\ensuremath{\alpha}}
\newunicodechar{β}{\ensuremath{\beta}}
\newunicodechar{γ}{\ensuremath{\gamma}}
\newunicodechar{δ}{\ensuremath{\delta}}
\newunicodechar{ε}{\ensuremath{\varepsilon}}
\newunicodechar{ζ}{\ensuremath{\zeta}}
\newunicodechar{η}{\ensuremath{\eta}}
\newunicodechar{θ}{\ensuremath{\theta}}
\newunicodechar{ι}{\ensuremath{\iota}}
\newunicodechar{κ}{\ensuremath{\kappa}}
\newunicodechar{λ}{\ensuremath{\lambda}}
\newunicodechar{μ}{\ensuremath{\mu}}
\newunicodechar{ν}{\ensuremath{\nu}}
\newunicodechar{ξ}{\ensuremath{\xi}}
\newunicodechar{π}{\ensuremath{\pi}}
\newunicodechar{ρ}{\ensuremath{\rho}}
\newunicodechar{σ}{\ensuremath{\sigma}}
\newunicodechar{τ}{\ensuremath{\tau}}
\newunicodechar{φ}{\ensuremath{\varphi}}
\newunicodechar{χ}{\ensuremath{\chi}}
\newunicodechar{ψ}{\ensuremath{\psi}}
\newunicodechar{ω}{\ensuremath{\omega}}
\newunicodechar{Γ}{\ensuremath{\Gamma}}
\newunicodechar{Δ}{\ensuremath{\Delta}}
\newunicodechar{Σ}{\ensuremath{\Sigma}}
\newunicodechar{Π}{\ensuremath{\Pi}}
\newunicodechar{Ω}{\ensuremath{\Omega}}

% Superscripts and subscripts  
\newunicodechar{⁻}{\ensuremath{^{-}}}
\newunicodechar{¹}{\ensuremath{^{1}}}
\newunicodechar{²}{\ensuremath{^{2}}}
\newunicodechar{³}{\ensuremath{^{3}}}
\newunicodechar{⁴}{\ensuremath{^{4}}}
\newunicodechar{⁵}{\ensuremath{^{5}}}
\newunicodechar{⁶}{\ensuremath{^{6}}}
\newunicodechar{⁷}{\ensuremath{^{7}}}
\newunicodechar{⁸}{\ensuremath{^{8}}}
\newunicodechar{⁹}{\ensuremath{^{9}}}
\newunicodechar{⁰}{\ensuremath{^{0}}}
\newunicodechar{ⁿ}{\ensuremath{^{n}}}
\newunicodechar{ᵒ}{\ensuremath{^{o}}}
\newunicodechar{ᵖ}{\ensuremath{^{p}}}
\newunicodechar{ᵐ}{\ensuremath{^{m}}}
\newunicodechar{ᵢ}{\ensuremath{_{i}}}
\newunicodechar{₀}{\ensuremath{_{0}}}
\newunicodechar{₁}{\ensuremath{_{1}}}
\newunicodechar{₂}{\ensuremath{_{2}}}
\newunicodechar{₃}{\ensuremath{_{3}}}
\newunicodechar{₄}{\ensuremath{_{4}}}
\newunicodechar{₅}{\ensuremath{_{5}}}
\newunicodechar{₆}{\ensuremath{_{6}}}
\newunicodechar{₇}{\ensuremath{_{7}}}
\newunicodechar{₈}{\ensuremath{_{8}}}
\newunicodechar{₉}{\ensuremath{_{9}}}
\newunicodechar{ₙ}{\ensuremath{_{n}}}
\newunicodechar{ₘ}{\ensuremath{_{m}}}

% Mathematical alphabets
\newunicodechar{𝒰}{\ensuremath{\mathcal{U}}}
\newunicodechar{𝒱}{\ensuremath{\mathcal{V}}}
\newunicodechar{𝒲}{\ensuremath{\mathcal{W}}}
\newunicodechar{𝒳}{\ensuremath{\mathcal{X}}}
\newunicodechar{𝒴}{\ensuremath{\mathcal{Y}}}
\newunicodechar{𝒵}{\ensuremath{\mathcal{Z}}}
\newunicodechar{𝓐}{\ensuremath{\mathcal{A}}}
\newunicodechar{𝓑}{\ensuremath{\mathcal{B}}}
\newunicodechar{𝓒}{\ensuremath{\mathcal{C}}}
\newunicodechar{𝓓}{\ensuremath{\mathcal{D}}}
\newunicodechar{𝓔}{\ensuremath{\mathcal{E}}}
\newunicodechar{𝓕}{\ensuremath{\mathcal{F}}}
\newunicodechar{𝓖}{\ensuremath{\mathcal{G}}}
\newunicodechar{𝓗}{\ensuremath{\mathcal{H}}}
\newunicodechar{𝓘}{\ensuremath{\mathcal{I}}}
\newunicodechar{𝓙}{\ensuremath{\mathcal{J}}}
\newunicodechar{𝓚}{\ensuremath{\mathcal{K}}}
\newunicodechar{𝓛}{\ensuremath{\mathcal{L}}}
\newunicodechar{𝓜}{\ensuremath{\mathcal{M}}}
\newunicodechar{𝓝}{\ensuremath{\mathcal{N}}}
\newunicodechar{𝓞}{\ensuremath{\mathcal{O}}}
\newunicodechar{𝓟}{\ensuremath{\mathcal{P}}}
\newunicodechar{𝓠}{\ensuremath{\mathcal{Q}}}
\newunicodechar{𝓡}{\ensuremath{\mathcal{R}}}
\newunicodechar{𝓢}{\ensuremath{\mathcal{S}}}
\newunicodechar{𝓣}{\ensuremath{\mathcal{T}}}
\newunicodechar{𝟙}{\ensuremath{\mathbb{1}}}
\newunicodechar{𝟘}{\ensuremath{\mathbb{0}}}
\newunicodechar{ℕ}{\ensuremath{\mathbb{N}}}
\newunicodechar{ℤ}{\ensuremath{\mathbb{Z}}}
\newunicodechar{ℚ}{\ensuremath{\mathbb{Q}}}
\newunicodechar{ℝ}{\ensuremath{\mathbb{R}}}
\newunicodechar{ℂ}{\ensuremath{\mathbb{C}}}


\usepackage{amsmath, amsthm, amssymb}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{geometry}
\geometry{margin=1in}

% Define colors for Lean syntax highlighting
\definecolor{leanKeyword}{RGB}{0, 0, 255}       % Blue for keywords
\definecolor{leanType}{RGB}{139, 0, 139}        % Dark magenta for types
\definecolor{leanString}{RGB}{0, 128, 0}        % Green for strings
\definecolor{leanComment}{RGB}{128, 128, 128}   % Gray for comments
\definecolor{leanDefinition}{RGB}{255, 140, 0}  % Dark orange for definitions
\definecolor{leanAttribute}{RGB}{255, 20, 147}  % Deep pink for attributes
\definecolor{leanBackground}{RGB}{250, 250, 250} % Light gray background

% Define Lean language for listings
\lstdefinelanguage{Lean}{
  % Keywords
  morekeywords=[1]{def, theorem, lemma, instance, class, structure, inductive,
    axiom, constant, variable, namespace, section, noncomputable, protected,
    private, abbrev, example, open, attribute, local, mutual, by, where,
    extends, deriving, end, import, prelude, theory, with, without, using,
    match, if, then, else, fun, have, show, from, let, in, do, begin, calc},
  % Types and Type constructors
  morekeywords=[2]{Type, Prop, Sort, Nat, Int, Bool, String, Char, List,
    Option, Unit, Prod, Sum, Sigma, Subtype, Set, Scheme, CommRingCat,
    AffineScheme, Opens, IsAffine, IsAffineOpen, Spec, Category, Functor,
    Iso, IsIso, CompactSpace, IsCompact, IsOpenImmersion, Equiv, Hom,
    pullback, PullbackCone, OpenCover, GlueData, Multicoequalizer},
  % Tactics (if they appear)
  morekeywords=[3]{simp, rfl, exact, apply, intro, cases, induction, refl,
    constructor, assumption, contradiction, trivial, sorry, admit, rw,
    convert, infer_instance, ext, rintro, obtain, refine, dsimp},
  % Sensitive
  sensitive=true,
  % Comments
  morecomment=[l]{--},
  morecomment=[n]{/-}{-/},
  % Strings
  morestring=[b]",
  % Style
  keywordstyle=[1]\color{leanKeyword}\bfseries,
  keywordstyle=[2]\color{leanType}\bfseries,
  keywordstyle=[3]\color{leanDefinition}\itshape,
  commentstyle=\color{leanComment}\itshape,
  stringstyle=\color{leanString},
  % Highlight attributes
  moredelim=[is][\color{leanAttribute}]{@[}{]},
  moredelim=[is][\color{leanAttribute}]{\#[}{]},
}

\lstset{
  language=Lean,
  basicstyle=\ttfamily\small,
  backgroundcolor=\color{leanBackground},
  breaklines=true,
  frame=single,
  framerule=0.5pt,
  rulecolor=\color{gray!30},
  numbers=left,
  numberstyle=\tiny\color{gray},
  numbersep=5pt,
  showstringspaces=false,
  captionpos=b,
  xleftmargin=10pt,
  framexleftmargin=10pt,
  }


           {$^{-1}$}{{$^{-1}$}}2
           {$^{op}$}{{$^{op}$}}2

           {$\mathcal{U}$}{{$\mathcal{U}$}}1
           {$\mathbb{1}$}{{$\mathbb{1}$}}

           {:=}{{$\mathrel{:=}$}}2

}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{instance}{Instance}

\title{Pullbacks of Schemes in Mathlib4\\
\large A Companion to \texttt{Pullbacks.lean}}
\author{}
\date{}

\begin{document}
\maketitle

\section{Introduction}

This document provides a natural language companion to the \texttt{Pullbacks.lean} file in Mathlib4. The file constructs fibered products (pullbacks) of schemes using gluing techniques, following Hartshorne's Theorem 3.3. The construction shows how to build pullbacks for arbitrary schemes by reducing to the affine case through open covers.

\section{Main Construction Strategy}

\subsection{The Gluing Approach}

The fundamental idea is to construct pullbacks via gluing:
\begin{itemize}
\item Given schemes $X$, $Y$, $Z$ and morphisms $f: X \to Z$, $g: Y \to Z$
\item For an open cover $\{U_i\}$ of $X$, if pullbacks $U_i \times_Z Y$ exist
\item Then we can glue these pullbacks to construct $X \times_Z Y$
\end{itemize}

This reduces the problem to the affine case, where pullbacks are constructed via tensor products of rings.

\section{The Pullback Namespace}

\subsection{Intersection Schemes}

\begin{lstlisting}
def v (i j : 𝒰.J) : Scheme :=
  pullback ((pullback.fst (𝒰.map i ≫ f) g) ≫ 𝒰.map i) (𝒰.map j)
\end{lstlisting}

\textbf{Natural Language:} For indices $i, j$ in an open cover, $V_{ij}$ represents the intersection of $U_i \times_Z Y$ and $U_j \times_Z Y$ over $X$. This is constructed as the pullback of the natural maps.

\subsection{Transition Maps}

\begin{lstlisting}
def t (i j : 𝒰.J) : v 𝒰 f g i j ⟶ v 𝒰 f g j i
\end{lstlisting}

\textbf{Natural Language:} The transition map $t_{ij}: V_{ij} \to V_{ji}$ is the canonical isomorphism given by the symmetry and associativity of pullbacks. This ensures that the intersections can be consistently glued.

\subsection{Properties of Transition Maps}

\begin{lstlisting}
theorem t_id (i : 𝒰.J) : t 𝒰 f g i i = 𝟙 _
\end{lstlisting}

\textbf{Natural Language:} The transition map from $V_{ii}$ to itself is the identity morphism.

\section{The Gluing Data Structure}

\subsection{The Main Gluing Construction}

\begin{lstlisting}
def gluing : Scheme.GlueData.{u} where
  J := 𝒰.J
  U i := pullback (𝒰.map i ≫ f) g
  V := fun ⟨i, j⟩ => v 𝒰 f g i j
  f _ _ := pullback.fst _ _
  t i j := t 𝒰 f g i j
  cocycle i j k := cocycle 𝒰 f g i j k
\end{lstlisting}

\textbf{Natural Language:} This constructs the gluing data needed to create the fibered product. The schemes $U_i = U_i \times_Z Y$ are glued together using the intersection schemes $V_{ij}$ and transition maps $t_{ij}$.

\subsection{Cocycle Condition}

\begin{lstlisting}
theorem cocycle (i j k : 𝒰.J) : t' 𝒰 f g i j k ≫ t' 𝒰 f g j k i ≫ t' 𝒰 f g k i j = 𝟙 _
\end{lstlisting}

\textbf{Natural Language:} The composition of transition maps around a triple satisfies the cocycle condition, ensuring that the gluing is well-defined.

\section{Projection Morphisms}

\subsection{First Projection}

\begin{lstlisting}
def p1 : (gluing 𝒰 f g).glued ⟶ X
\end{lstlisting}

\textbf{Natural Language:} The first projection $p_1: X \times_Z Y \to X$ is obtained by gluing the natural projections from each $U_i \times_Z Y$ to $U_i \subseteq X$.

\subsection{Second Projection}

\begin{lstlisting}
def p2 : (gluing 𝒰 f g).glued ⟶ Y
\end{lstlisting}

\textbf{Natural Language:} The second projection $p_2: X \times_Z Y \to Y$ is obtained by gluing the natural projections from each $U_i \times_Z Y$ to $Y$.

\subsection{Pullback Square Property}

\begin{lstlisting}
theorem p_comm : p1 𝒰 f g ≫ f = p2 𝒰 f g ≫ g
\end{lstlisting}

\textbf{Natural Language:} The glued scheme forms a pullback square: $p_1 \circ f = p_2 \circ g$, confirming that we have constructed the fibered product correctly.

\section{Universal Property}

\subsection{Lifting Property}

\begin{lstlisting}
def gluedLift : s.pt ⟶ (gluing 𝒰 f g).glued
\end{lstlisting}

\textbf{Natural Language:} Given any pullback cone $s$ for the diagram $X \leftarrow Z \rightarrow Y$, there exists a unique morphism from the apex of $s$ to the glued pullback.

\subsection{Main Theorem: Glued Pullback is a Limit}

\begin{lstlisting}
def gluedIsLimit : IsLimit (PullbackCone.mk _ _ (p_comm 𝒰 f g))
\end{lstlisting}

\textbf{Natural Language:} The glued construction satisfies the universal property of pullbacks, making it the categorical pullback (fibered product) in the category of schemes.

\section{Special Cases and Applications}

\subsection{Affine-Affine Pullbacks}

\begin{lstlisting}
instance affine_hasPullback {A B C : CommRingCat}
    (f : Spec A ⟶ Spec C)
    (g : Spec B ⟶ Spec C) : HasPullback f g
\end{lstlisting}

\textbf{Natural Language:} When all schemes are affine, pullbacks exist and are computed using the tensor product construction in commutative rings.

\subsection{General Existence}

\begin{lstlisting}
instance : HasPullbacks Scheme
\end{lstlisting}

\textbf{Natural Language:} The category of schemes has all pullbacks. This is proven using the gluing construction applied to affine covers.

\section{Spectrum Tensor Product Isomorphism}

\subsection{The Main Isomorphism}

\begin{lstlisting}
def pullbackSpecIso :
    pullback (Spec.map (CommRingCat.ofHom (algebraMap R S)))
      (Spec.map (CommRingCat.ofHom (algebraMap R T))) ≅ Spec(S ⊗[R] T)
\end{lstlisting}

\textbf{Natural Language:} For commutative rings $R$, $S$, $T$ with algebra structures, the pullback of $\mathrm{Spec}(S) \to \mathrm{Spec}(R) \leftarrow \mathrm{Spec}(T)$ is isomorphic to $\mathrm{Spec}(S \otimes_R T)$.

\subsection{Projection Formulas}

\begin{lstlisting}
lemma pullbackSpecIso_inv_fst :
    (pullbackSpecIso R S T).inv ≫ pullback.fst _ _ = Spec.map (ofHom includeLeftRingHom)
\end{lstlisting}

\textbf{Natural Language:} The first projection corresponds to the ring homomorphism $s \mapsto s \otimes 1$ from $S$ to $S \otimes_R T$.

\section{Open Covers of Pullbacks}

\subsection{Cover by Left Components}

\begin{lstlisting}
def openCoverOfLeft (𝒰 : OpenCover X) (f : X ⟶ Z) (g : Y ⟶ Z) : OpenCover (pullback f g)
\end{lstlisting}

\textbf{Natural Language:} Given an open cover $\{U_i\}$ of $X$, the pullback $X \times_Z Y$ is covered by the schemes $U_i \times_Z Y$.

\subsection{Cover by Both Components}

\begin{lstlisting}
def openCoverOfLeftRight (𝒰X : X.OpenCover) (𝒰Y : Y.OpenCover) (f : X ⟶ Z) (g : Y ⟶ Z) :
    (pullback f g).OpenCover
\end{lstlisting}

\textbf{Natural Language:} Given open covers of both $X$ and $Y$, the pullback is covered by all pairwise products $U_i \times_Z V_j$.

\section{Geometric Properties}

\subsection{Preservation of Affine Property}

\begin{lstlisting}
instance isAffine_of_isAffine_isAffine_isAffine {X Y Z : Scheme}
    (f : X ⟶ Z) (g : Y ⟶ Z) [IsAffine X] [IsAffine Y] [IsAffine Z] :
    IsAffine (pullback f g)
\end{lstlisting}

\textbf{Natural Language:} The pullback of affine schemes over an affine base is affine. This follows from the tensor product construction for affine schemes.

\subsection{Empty Pullbacks}

\begin{lstlisting}
theorem _root_.AlgebraicGeometry.Scheme.isEmpty_pullback
    {X Y S : Scheme.{u}} (f : X ⟶ S) (g : Y ⟶ S)
    (H : Disjoint (Set.range f.base) (Set.range g.base)) : IsEmpty ↑(Limits.pullback f g)
\end{lstlisting}

\textbf{Natural Language:} If the images of $f$ and $g$ are disjoint in $S$, then the pullback is empty.

\section{Applications to Cartesian Monoidal Structure}

\subsection{Cartesian Structure on Over Categories}

\begin{lstlisting}
instance : CartesianMonoidalCategory (Over S)
\end{lstlisting}

\textbf{Natural Language:} The existence of pullbacks gives the category of $S$-schemes a cartesian monoidal structure, where the tensor product is the pullback over $S$.

\section{Conclusion}

The pullback construction in \texttt{Pullbacks.lean} provides:
\begin{itemize}
\item A systematic way to construct fibered products of arbitrary schemes
\item Reduction of the general case to the well-understood affine case
\item Complete proof that the category of schemes has all pullbacks
\item Explicit constructions for various special cases and covers
\item Foundation for cartesian monoidal structure in algebraic geometry
\end{itemize}

This construction is fundamental to many areas of algebraic geometry, including base change, families of schemes, and moduli theory.

\end{document}