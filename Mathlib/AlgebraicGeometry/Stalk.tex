\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{geometry}
\geometry{margin=1in}

% Define colors for Lean syntax highlighting
\definecolor{leanKeyword}{RGB}{0, 0, 255}       % Blue for keywords
\definecolor{leanType}{RGB}{139, 0, 139}        % Dark magenta for types
\definecolor{leanString}{RGB}{0, 128, 0}        % Green for strings
\definecolor{leanComment}{RGB}{128, 128, 128}   % Gray for comments
\definecolor{leanDefinition}{RGB}{255, 140, 0}  % Dark orange for definitions
\definecolor{leanAttribute}{RGB}{255, 20, 147}  % Deep pink for attributes
\definecolor{leanBackground}{RGB}{250, 250, 250} % Light gray background

% Define Lean language for listings
\lstdefinelanguage{Lean}{
  % Keywords
  morekeywords=[1]{def, theorem, lemma, instance, class, structure, inductive,
    axiom, constant, variable, namespace, section, noncomputable, protected,
    private, abbrev, example, open, attribute, local, mutual, by, where,
    extends, deriving, end, import, prelude, theory, with, without, using,
    match, if, then, else, fun, have, show, from, let, in, do, begin, calc},
  % Types and Type constructors
  morekeywords=[2]{Type, Prop, Sort, Nat, Int, Bool, String, Char, List,
    Option, Unit, Prod, Sum, Sigma, Subtype, Set, Scheme, CommRingCat,
    AffineScheme, Opens, IsAffine, IsAffineOpen, Spec, Category, Functor,
    Iso, IsIso, CompactSpace, IsCompact, IsOpenImmersion, Equiv, Hom,
    IsPreimmersion, IsLocalRing, IsLocalHom, closedPoint},
  % Tactics (if they appear)
  morekeywords=[3]{simp, rfl, exact, apply, intro, cases, induction, refl,
    constructor, assumption, contradiction, trivial, sorry, admit, rw,
    convert, infer_instance, ext, rintro, obtain, refine, dsimp},
  % Sensitive
  sensitive=true,
  % Comments
  morecomment=[l]{--},
  morecomment=[n]{/-}{-/},
  % Strings
  morestring=[b]",
  % Style
  keywordstyle=[1]\color{leanKeyword}\bfseries,
  keywordstyle=[2]\color{leanType}\bfseries,
  keywordstyle=[3]\color{leanDefinition}\itshape,
  commentstyle=\color{leanComment}\itshape,
  stringstyle=\color{leanString},
  % Highlight attributes
  moredelim=[is][\color{leanAttribute}]{@[}{]},
  moredelim=[is][\color{leanAttribute}]{\#[}{]},
}

\lstset{
  language=Lean,
  basicstyle=\ttfamily\small,
  backgroundcolor=\color{leanBackground},
  breaklines=true,
  frame=single,
  framerule=0.5pt,
  rulecolor=\color{gray!30},
  numbers=left,
  numberstyle=\tiny\color{gray},
  numbersep=5pt,
  showstringspaces=false,
  captionpos=b,
  xleftmargin=10pt,
  framexleftmargin=10pt,
  % Unicode replacements for mathematical symbols
  literate={Œì}{{$\Gamma$}}1
           {‚ä§}{{$\top$}}1
           {‚ü∂}{{$\to$}}2
           {‚âÖ}{{$\cong$}}1
           {‚äÜ}{{$\subseteq$}}1
           {‚®Ü}{{$\bigsqcup$}}1
           {‚àà}{{$\in$}}1
           {‚àÉ}{{$\exists$}}1
           {‚àß}{{$\land$}}1
           {‚Åª¬π·µÅ}{{$^{-1}U$}}3
           {‚Åª¬π}{{$^{-1}$}}2
           {‚â´}{{>>}}1
           {‚â§}{{$\leq$}}1
           {·µí·µñ}{{$^{op}$}}2
           {‚•§}{{$\Rightarrow$}}2
           {‚âå}{{$\simeq$}}1
           {‚ãô}{{$\ggg$}}1
           {‚àÄ}{{$\forall$}}1
           {‚Üë}{{$\uparrow$}}1
           {ùí∞}{{$\mathcal{U}$}}1
           {ùüô}{{$\mathbb{1}$}}1
           {''·µÅ}{{''U}}2
           {‚â™‚â´}{{$\ll\gg$}}2
           {Œπ}{{$\iota$}}1
           {‚Üí}{{$\to$}}1
           {·µÅ}{{U}}1
           {:=}{{$\mathrel{:=}$}}2
           {√ó}{{$\times$}}1
           {‚ß∏}{{$/\!/$}}1
           {‚Üî}{{$\leftrightarrow$}}1
           {‚ü®}{{$\langle$}}1
           {‚ü©}{{$\rangle$}}1
           {Œ±}{{$\alpha$}}1
           {Œ≤}{{$\beta$}}1
           {Œ≥}{{$\gamma$}}1
           {Œ¥}{{$\delta$}}1
           {Œµ}{{$\varepsilon$}}1
           {Œª}{{$\lambda$}}1
           {Œº}{{$\mu$}}1
           {œÉ}{{$\sigma$}}1
           {œÑ}{{$\tau$}}1
           {œÜ}{{$\varphi$}}1
           {œà}{{$\psi$}}1
           {œâ}{{$\omega$}}1
           {‚àû}{{$\infty$}}1
           {‚àÇ}{{$\partial$}}1
           {‚àá}{{$\nabla$}}1
           {‚§≥}{{$\leadsto$}}1
           {ùí™}{{$\mathcal{O}$}}1
}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{instance}{Instance}

\title{Stalks of Schemes in Mathlib4\\
\large A Companion to \texttt{Stalk.lean}}
\author{}
\date{}

\begin{document}
\maketitle

\section{Introduction}

This document provides a natural language companion to the \texttt{Stalk.lean} file in Mathlib4. The file develops the theory of stalks for schemes, which are fundamental algebraic objects that capture the local behavior of schemes at individual points. Stalks provide the bridge between the geometric intuition of "local rings of functions at a point" and the algebraic machinery needed for rigorous scheme theory.

In classical algebraic geometry, the stalk at a point corresponds to the localization of the coordinate ring at the prime ideal corresponding to that point. In general scheme theory, stalks are defined as direct limits of sections over neighborhoods of the point, providing a systematic way to study local properties.

The stalk theory is essential for:
\begin{itemize}
\item Understanding the local algebraic structure at each point
\item Defining and studying morphisms between schemes
\item Connecting scheme theory to classical algebraic geometry
\item Developing the theory of coherent sheaves and local properties
\end{itemize}

\section{Morphisms from Spec of Stalks}

\subsection{Definition via Affine Opens}

\begin{lstlisting}
noncomputable def IsAffineOpen.fromSpecStalk
    {X : Scheme} {U : X.Opens} (hU : IsAffineOpen U) {x : X} (hxU : x ‚àà U) :
    Spec (X.presheaf.stalk x) ‚ü∂ X :=
  Spec.map (X.presheaf.germ _ x hxU) ‚â´ hU.fromSpec
\end{lstlisting}

\textbf{Mathematical Significance:} For any affine open neighborhood $U$ of a point $x$, we can construct a canonical morphism from $\mathrm{Spec}(\mathcal{O}_{X,x})$ to $X$. This morphism is built by composing the natural map induced by the germ homomorphism with the canonical inclusion of the affine open.

This construction provides a way to "embed" the spectrum of the stalk (which represents the local algebraic data at $x$) back into the original scheme $X$.

\subsection{Independence of Choice}

\begin{lstlisting}
theorem IsAffineOpen.fromSpecStalk_eq (x : X) (hxU : x ‚àà U) (hxV : x ‚àà V) :
    hU.fromSpecStalk hxU = hV.fromSpecStalk hxV := by
  obtain ‚ü®U', h‚ÇÅ, h‚ÇÇ, h‚ÇÉ : U' ‚â§ U ‚äì V‚ü© :=
    Opens.isBasis_iff_nbhd.mp (isBasis_affine_open X) (show x ‚àà U ‚äì V from ‚ü®hxU, hxV‚ü©)
  -- Technical proof showing the constructions agree
\end{lstlisting}

\textbf{Mathematical Significance:} The morphism $\mathrm{Spec}(\mathcal{O}_{X,x}) \to X$ does not depend on the choice of affine open neighborhood used in its construction. This is crucial because it ensures that the construction is well-defined and canonical.

The proof uses the fact that affine opens form a basis for the topology, so any two affine neighborhoods can be refined by a smaller affine neighborhood, and the constructions agree when traced through this refinement.

\subsection{Canonical Definition}

\begin{lstlisting}
noncomputable def Scheme.fromSpecStalk (X : Scheme) (x : X) :
    Spec (X.presheaf.stalk x) ‚ü∂ X :=
  (isAffineOpen_opensRange (X.affineOpenCover.map x)).fromSpecStalk (X.affineOpenCover.covers x)
\end{lstlisting}

\textbf{Mathematical Significance:} Using the independence result, we can define the canonical morphism $\mathrm{Spec}(\mathcal{O}_{X,x}) \to X$ using any convenient affine open neighborhood. The definition uses the affine open cover, but the result is independent of this choice.

This morphism encodes the idea that the spectrum of the stalk represents the "formal neighborhood" of the point $x$ in $X$.

\section{Properties of the Canonical Morphism}

\subsection{Closed Point Behavior}

\begin{lstlisting}
@[simp]
lemma fromSpecStalk_closedPoint {x : X} :
    (X.fromSpecStalk x).base (closedPoint (X.presheaf.stalk x)) = x :=
  IsAffineOpen.fromSpecStalk_closedPoint _ _
\end{lstlisting}

\textbf{Mathematical Significance:} The morphism $\mathrm{Spec}(\mathcal{O}_{X,x}) \to X$ maps the closed point of the stalk spectrum (corresponding to the maximal ideal of $\mathcal{O}_{X,x}$) to the original point $x$. This formalizes the intuitive idea that the stalk "sits at" the point $x$.

\subsection{Preimmersion Property}

\begin{lstlisting}
instance {X : Scheme.{u}} (x : X) : IsPreimmersion (X.fromSpecStalk x) :=
  IsAffineOpen.fromSpecStalk_isPreimmersion _ _ _
\end{lstlisting}

\textbf{Mathematical Significance:} The canonical morphism from $\mathrm{Spec}(\mathcal{O}_{X,x})$ to $X$ is a preimmersion, which means it is a composition of an open immersion followed by a closed immersion. This ensures that the morphism has good geometric properties and behaves well with respect to the topology.

\section{Range and Specialization}

\subsection{Range Characterization}

\begin{lstlisting}
@[stacks 01J7]
lemma range_fromSpecStalk {x : X} :
    Set.range (X.fromSpecStalk x).base = { y | y ‚§≥ x } := by
\end{lstlisting}

\textbf{Mathematical Significance:} The image of the morphism $\mathrm{Spec}(\mathcal{O}_{X,x}) \to X$ consists exactly of those points $y$ that specialize to $x$ (written $y \leadsto x$). This provides a beautiful geometric interpretation: the spectrum of the stalk parametrizes all the ways points can specialize to $x$.

In classical terms, if $x$ corresponds to a prime ideal $\mathfrak{p}$, then the points specializing to $x$ correspond to prime ideals contained in $\mathfrak{p}$, which is exactly what the spectrum of the localization $R_\mathfrak{p}$ parametrizes.

\subsection{Compatibility with Specialization}

\begin{lstlisting}
@[reassoc (attr := simp)]
lemma Spec_map_stalkSpecializes_fromSpecStalk {x y : X} (h : x ‚§≥ y) :
    Spec.map (X.presheaf.stalkSpecializes h) ‚â´ X.fromSpecStalk y = X.fromSpecStalk x := by
\end{lstlisting}

\textbf{Mathematical Significance:} If $x$ specializes to $y$, then there is a natural map of stalks $\mathcal{O}_{X,y} \to \mathcal{O}_{X,x}$, and the induced map $\mathrm{Spec}(\mathcal{O}_{X,x}) \to \mathrm{Spec}(\mathcal{O}_{X,y})$ is compatible with the fromSpecStalk morphisms.

This compatibility ensures that the stalk construction behaves functorially with respect to specializations and maintains the geometric relationships between points.

\section{Functoriality}

\subsection{Compatibility with Morphisms}

\begin{lstlisting}
@[reassoc (attr := simp)]
lemma Spec_map_stalkMap_fromSpecStalk {x} :
    Spec.map (f.stalkMap x) ‚â´ Y.fromSpecStalk _ = X.fromSpecStalk x ‚â´ f := by
\end{lstlisting}

\textbf{Mathematical Significance:} For a morphism $f: X \to Y$ and a point $x \in X$, the natural diagram involving stalk maps and fromSpecStalk morphisms commutes. This fundamental compatibility ensures that the stalk construction is functorial and preserves the relationships established by scheme morphisms.

The commutativity expresses the fact that we can either:
\begin{enumerate}
\item Map the stalk and then apply fromSpecStalk, or
\item Apply fromSpecStalk and then apply the original morphism
\end{enumerate}
and get the same result.

\section{Local Rings and Closed Points}

\subsection{Stalk-Closed Point Isomorphism}

\begin{lstlisting}
noncomputable
def stalkClosedPointIso :
    (Spec R).presheaf.stalk (closedPoint R) ‚âÖ R :=
  StructureSheaf.stalkIso _ _ ‚â™‚â´ (IsLocalization.atUnits R
      (closedPoint R).asIdeal.primeCompl fun _ ‚Ü¶ not_not.mp).toRingEquiv.toCommRingCatIso.symm
\end{lstlisting}

\textbf{Mathematical Significance:} For a local ring $R$, the stalk of $\mathrm{Spec}(R)$ at the closed point (corresponding to the maximal ideal) is naturally isomorphic to $R$ itself. This isomorphism captures the fact that localizing a local ring at its maximal ideal gives back the original ring.

This result provides the foundation for understanding how stalks behave in the local case and establishes the connection between abstract stalk theory and concrete local rings.

\subsection{Spec and FromSpecStalk}

\begin{lstlisting}
lemma Spec_stalkClosedPointIso :
    Spec.map (stalkClosedPointIso R).inv = (Spec R).fromSpecStalk (closedPoint R) := by
  rw [stalkClosedPointIso_inv, Scheme.Spec_fromSpecStalk']
\end{lstlisting}

\textbf{Mathematical Significance:} The canonical isomorphism between the stalk and the original ring induces a morphism that coincides with the fromSpecStalk construction. This provides a concrete computational handle on the abstract fromSpecStalk morphism in the case of spectra of local rings.

\section{Local Homomorphisms and Morphisms}

\subsection{Stalk Maps from Morphisms}

\begin{lstlisting}
noncomputable
def stalkClosedPointTo :
    X.presheaf.stalk (f.base (closedPoint R)) ‚ü∂ R :=
  f.stalkMap (closedPoint R) ‚â´ (stalkClosedPointIso R).hom
\end{lstlisting}

\textbf{Mathematical Significance:} Given a morphism $f: \mathrm{Spec}(R) \to X$ where $R$ is a local ring, we obtain a canonical ring homomorphism from the stalk of $X$ at $f(\mathfrak{m})$ (where $\mathfrak{m}$ is the closed point of $\mathrm{Spec}(R)$) to $R$.

This construction is fundamental for understanding how morphisms from spectra of local rings encode local ring homomorphisms.

\subsection{Local Homomorphism Property}

\begin{lstlisting}
instance isLocalHom_stalkClosedPointTo :
    IsLocalHom (stalkClosedPointTo f).hom :=
  inferInstanceAs <| IsLocalHom (f.stalkMap (closedPoint R) ‚â´ (stalkClosedPointIso R).hom).hom
\end{LST}

\textbf{Mathematical Significance:} The ring homomorphism obtained from a morphism to a spectrum of a local ring is automatically a local homomorphism (i.e., it maps the maximal ideal to the maximal ideal). This reflects the geometric fact that morphisms to spectra of local rings naturally encode local algebraic data.

\section{Universal Property}

\subsection{Equivalence with Local Ring Homomorphisms}

\begin{lstlisting}
@[simps]
noncomputable
def SpecToEquivOfLocalRing :
    (Spec R ‚ü∂ X) ‚âÉ Œ£ x, { f : X.presheaf.stalk x ‚ü∂ R // IsLocalHom f.hom } where
  toFun f := ‚ü®f.base (closedPoint R), Scheme.stalkClosedPointTo f, inferInstance‚ü©
  invFun xf := Spec.map xf.2.1 ‚â´ X.fromSpecStalk xf.1
\end{lstlisting}

\textbf{Mathematical Significance:} This establishes a fundamental bijection between:
\begin{itemize}
\item Morphisms from $\mathrm{Spec}(R)$ (where $R$ is a local ring) to a scheme $X$
\item Pairs $(x, \phi)$ where $x$ is a point of $X$ and $\phi: \mathcal{O}_{X,x} \to R$ is a local ring homomorphism
\end{itemize}

This universal property is one of the most important results in scheme theory, as it shows that morphisms from spectra of local rings correspond exactly to pointed local ring homomorphisms. It provides the algebraic foundation for understanding how "geometric points with values in local rings" work in scheme theory.

\section{Geometric Significance}

\subsection{Local-Global Principle}

The stalk theory developed in this file establishes several crucial local-global principles:

\begin{itemize}
\item \textbf{Local Detection of Properties}: Many properties of morphisms and schemes can be detected by examining their behavior on stalks
\item \textbf{Localization Principle}: Global problems can often be reduced to local problems by passing to stalks
\item \textbf{Functorial Behavior}: All constructions respect morphisms and maintain the relationships between different parts of the geometry
\end{itemize}

\subsection{Connection to Classical Algebraic Geometry}

The stalk construction provides the bridge between modern scheme theory and classical algebraic geometry:

\begin{itemize}
\item \textbf{Local Rings}: Stalks generalize the notion of local rings of functions at points on varieties
\item \textbf{Localization}: The construction matches classical localization of coordinate rings at prime ideals
\item \textbf{Specialization}: The range characterization captures the classical notion of how points can degenerate to others
\end{itemize}

\subsection{Applications}

The stalk theory has numerous applications throughout algebraic geometry:

\begin{itemize}
\item \textbf{Dimension Theory}: Local dimensions can be computed using stalks
\item \textbf{Smoothness and Singularities}: Smooth and singular points can be detected through stalk properties
\item \textbf{Coherent Sheaves}: The theory of coherent sheaves relies heavily on stalk computations
\item \textbf{√âtale and Flat Morphisms}: Many important classes of morphisms are characterized by their behavior on stalks
\item \textbf{Base Change}: Stalks behave predictably under base change operations
\end{itemize}

The stalk construction thus provides both the theoretical foundation and practical tools needed for much of modern algebraic geometry, making it one of the most important technical developments in the field.

\end{document}