\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{geometry}
\geometry{margin=1in}

% Define colors for Lean syntax highlighting
\definecolor{leanKeyword}{RGB}{0, 0, 255}       % Blue for keywords
\definecolor{leanType}{RGB}{139, 0, 139}        % Dark magenta for types
\definecolor{leanString}{RGB}{0, 128, 0}        % Green for strings
\definecolor{leanComment}{RGB}{128, 128, 128}   % Gray for comments
\definecolor{leanDefinition}{RGB}{255, 140, 0}  % Dark orange for definitions
\definecolor{leanAttribute}{RGB}{255, 20, 147}  % Deep pink for attributes
\definecolor{leanBackground}{RGB}{250, 250, 250} % Light gray background

% Define Lean language for listings
\lstdefinelanguage{Lean}{
  % Keywords
  morekeywords=[1]{def, theorem, lemma, instance, class, structure, inductive,
    axiom, constant, variable, namespace, section, noncomputable, protected,
    private, abbrev, example, open, attribute, local, mutual, by, where,
    extends, deriving, end, import, prelude, theory, with, without, using,
    match, if, then, else, fun, have, show, from, let, in, do, begin, calc},
  % Types and Type constructors
  morekeywords=[2]{Type, Prop, Sort, Nat, Int, Bool, String, Char, List,
    Option, Unit, Prod, Sum, Sigma, Subtype, Set, Scheme, CommRingCat,
    AffineScheme, Opens, IsAffine, IsAffineOpen, Spec, Category, Functor,
    Iso, IsIso, CompactSpace, IsCompact, IsOpenImmersion, Equiv, Hom, LocallyRingedSpace,
    TopCat, SheafedSpace, PresheafedSpace, PrimeSpectrum, StructureSheaf},
  % Tactics (if they appear)
  morekeywords=[3]{simp, rfl, exact, apply, intro, cases, induction, refl,
    constructor, assumption, contradiction, trivial, sorry, admit, rw,
    convert, infer_instance, ext, rintro, obtain, refine, dsimp},
  % Sensitive
  sensitive=true,
  % Comments
  morecomment=[l]{--},
  morecomment=[n]{/-}{-/},
  % Strings
  morestring=[b]",
  % Style
  keywordstyle=[1]\color{leanKeyword}\bfseries,
  keywordstyle=[2]\color{leanType}\bfseries,
  keywordstyle=[3]\color{leanDefinition}\itshape,
  commentstyle=\color{leanComment}\itshape,
  stringstyle=\color{leanString},
  % Highlight attributes
  moredelim=[is][\color{leanAttribute}]{@[}{]},
  moredelim=[is][\color{leanAttribute}]{\#[}{]},
}

\lstset{
  language=Lean,
  basicstyle=\ttfamily\small,
  backgroundcolor=\color{leanBackground},
  breaklines=true,
  frame=single,
  framerule=0.5pt,
  rulecolor=\color{gray!30},
  numbers=left,
  numberstyle=\tiny\color{gray},
  numbersep=5pt,
  showstringspaces=false,
  captionpos=b,
  xleftmargin=10pt,
  framexleftmargin=10pt,
  % Unicode replacements for mathematical symbols
  literate={Œì}{{$\Gamma$}}1
           {‚ä§}{{$\top$}}1
           {‚ü∂}{{$\to$}}2
           {‚âÖ}{{$\cong$}}1
           {‚äÜ}{{$\subseteq$}}1
           {‚®Ü}{{$\bigsqcup$}}1
           {‚àà}{{$\in$}}1
           {‚àÉ}{{$\exists$}}1
           {‚àß}{{$\land$}}1
           {‚Åª¬π·µÅ}{{$^{-1}U$}}3
           {‚Åª¬π}{{$^{-1}$}}2
           {‚â´}{{>>}}1
           {‚â§}{{$\leq$}}1
           {·µí·µñ}{{$^{op}$}}2
           {‚•§}{{$\Rightarrow$}}2
           {‚âå}{{$\simeq$}}1
           {‚ãô}{{$\ggg$}}1
           {‚àÄ}{{$\forall$}}1
           {‚Üë}{{$\uparrow$}}1
           {ùí∞}{{$\mathcal{U}$}}1
           {ùüô}{{$\mathbb{1}$}}1
           {''·µÅ}{{''U}}2
           {‚â™‚â´}{{$\ll\gg$}}2
           {Œπ}{{$\iota$}}1
           {‚Üí}{{$\to$}}1
           {·µÅ}{{U}}1
           {:=}{{$\mathrel{:=}$}}2
           {√ó}{{$\times$}}1
           {‚ß∏}{{$/\!/$}}1
           {‚Üî}{{$\leftrightarrow$}}1
           {‚ü®}{{$\langle$}}1
           {‚ü©}{{$\rangle$}}1
           {Œ±}{{$\alpha$}}1
           {Œ≤}{{$\beta$}}1
           {Œ≥}{{$\gamma$}}1
           {Œ¥}{{$\delta$}}1
           {Œµ}{{$\varepsilon$}}1
           {Œª}{{$\lambda$}}1
           {Œº}{{$\mu$}}1
           {œÉ}{{$\sigma$}}1
           {œÑ}{{$\tau$}}1
           {œÜ}{{$\varphi$}}1
           {œà}{{$\psi$}}1
           {œâ}{{$\omega$}}1
           {‚àû}{{$\infty$}}1
           {‚àÇ}{{$\partial$}}1
           {‚àá}{{$\nabla$}}1
}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{instance}{Instance}

\title{The Spec Functor in Mathlib4\\
\large A Companion to \texttt{Spec.lean}}
\author{}
\date{}

\begin{document}
\maketitle

\section{Introduction}

This document provides a natural language companion to the \texttt{Spec.lean} file in Mathlib4. The file defines the spectrum functor $\mathrm{Spec}$ from commutative rings to locally ringed spaces, which is fundamental to algebraic geometry. The construction proceeds in three stages, building up structure incrementally: first as topological spaces, then as sheafed spaces, and finally as locally ringed spaces.

The spectrum construction is the bridge between algebra and geometry, allowing us to translate problems about rings into geometric problems about spaces and vice versa.

\section{Implementation Strategy}

The Spec functor is defined in three consecutive steps, each with more structure:

\begin{enumerate}
\item $\mathrm{Spec.toTop}$: from rings to topological spaces
\item $\mathrm{Spec.toSheafedSpace}$: from rings to sheafed spaces
\item $\mathrm{Spec.toLocallyRingedSpace}$: from rings to locally ringed spaces
\end{enumerate}

This layered approach makes the construction more manageable and allows for reuse of the intermediate stages.

\section{Topological Space Level}

\subsection{Objects}

\begin{lstlisting}
def Spec.topObj (R : CommRingCat.{u}) : TopCat :=
  TopCat.of (PrimeSpectrum R)
\end{lstlisting}

\textbf{Natural Language:} The spectrum of a commutative ring $R$ as a topological space is simply the prime spectrum $\mathrm{Spec}(R)$, consisting of all prime ideals of $R$ equipped with the Zariski topology.

\subsection{Morphisms}

\begin{lstlisting}
def Spec.topMap {R S : CommRingCat.{u}} (f : R ‚ü∂ S) : Spec.topObj S ‚ü∂ Spec.topObj R :=
  TopCat.ofHom (PrimeSpectrum.comap f.hom)
\end{lstlisting}

\textbf{Natural Language:} A ring homomorphism $f: R \to S$ induces a continuous map $\mathrm{Spec}(S) \to \mathrm{Spec}(R)$ by taking the preimage of prime ideals. Note the contravariant nature: morphisms of rings induce morphisms in the opposite direction on spectra.

\subsection{Functoriality}

\begin{lstlisting}
theorem Spec.topMap_id (R : CommRingCat.{u}) : Spec.topMap (ùüô R) = ùüô (Spec.topObj R)

theorem Spec.topMap_comp {R S T : CommRingCat.{u}} (f : R ‚ü∂ S) (g : S ‚ü∂ T) :
    Spec.topMap (f ‚â´ g) = Spec.topMap g ‚â´ Spec.topMap f
\end{lstlisting}

\textbf{Natural Language:} The construction respects identities and composition, making it a genuine contravariant functor. The composition formula shows the order reversal characteristic of contravariant functors.

\subsection{The Topological Functor}

\begin{lstlisting}
def Spec.toTop : CommRingCat.{u}·µí·µñ ‚•§ TopCat where
  obj R := Spec.topObj (unop R)
  map {_ _} f := Spec.topMap f.unop
\end{lstlisting}

\textbf{Natural Language:} By working in the opposite category of rings, we can present Spec as a covariant functor from $\mathbf{CRing}^{op}$ to $\mathbf{Top}$.

\section{Sheafed Space Level}

\subsection{Objects with Structure Sheaves}

\begin{lstlisting}
def Spec.sheafedSpaceObj (R : CommRingCat.{u}) : SheafedSpace CommRingCat where
  carrier := Spec.topObj R
  presheaf := (structureSheaf R).1
  IsSheaf := (structureSheaf R).2
\end{lstlisting}

\textbf{Natural Language:} The spectrum of $R$ as a sheafed space consists of the prime spectrum as the underlying topological space, equipped with the structure sheaf. The structure sheaf assigns to each open set the appropriate localization of $R$.

\subsection{Morphisms of Sheafed Spaces}

\begin{lstlisting}
def Spec.sheafedSpaceMap {R S : CommRingCat.{u}} (f : R ‚ü∂ S) :
    Spec.sheafedSpaceObj S ‚ü∂ Spec.sheafedSpaceObj R where
  base := Spec.topMap f
  c :=
    { app := fun U => CommRingCat.ofHom <|
        comap f.hom (unop U) ((TopologicalSpace.Opens.map (Spec.topMap f)).obj (unop U)) fun _ => id
      naturality := fun {_ _} _ => by ext; rfl }
\end{lstlisting}

\textbf{Natural Language:} A ring homomorphism $f: R \to S$ induces a morphism of sheafed spaces. The underlying map is the topological map defined earlier, and the sheaf morphism is given by the comap construction, which provides the appropriate maps between structure sheaves.

\subsection{Functoriality Properties}

\begin{lstlisting}
theorem Spec.sheafedSpaceMap_id {R : CommRingCat.{u}} :
    Spec.sheafedSpaceMap (ùüô R) = ùüô (Spec.sheafedSpaceObj R)

theorem Spec.sheafedSpaceMap_comp {R S T : CommRingCat.{u}} (f : R ‚ü∂ S) (g : S ‚ü∂ T) :
    Spec.sheafedSpaceMap (f ‚â´ g) = Spec.sheafedSpaceMap g ‚â´ Spec.sheafedSpaceMap f
\end{lstlisting}

\textbf{Natural Language:} The sheafed space construction also preserves identities and composition, confirming that we have a well-defined contravariant functor at the sheafed space level.

\subsection{The Sheafed Space Functor}

\begin{lstlisting}
def Spec.toSheafedSpace : CommRingCat.{u}·µí·µñ ‚•§ SheafedSpace CommRingCat where
  obj R := Spec.sheafedSpaceObj (unop R)
  map f := Spec.sheafedSpaceMap f.unop
  map_comp f g := by simp [Spec.sheafedSpaceMap_comp]
\end{lstlisting}

\textbf{Natural Language:} This gives us a contravariant functor from commutative rings to sheafed spaces over commutative rings.

\section{Presheafed Space Perspective}

\subsection{Forgetful Functor}

\begin{lstlisting}
def Spec.toPresheafedSpace : CommRingCat.{u}·µí·µñ ‚•§ PresheafedSpace CommRingCat :=
  Spec.toSheafedSpace ‚ãô SheafedSpace.forgetToPresheafedSpace
\end{lstlisting}

\textbf{Natural Language:} By composing with the forgetful functor, we can also view Spec as producing presheafed spaces. This perspective is sometimes useful for certain constructions and proofs.

\section{Locally Ringed Space Level}

\subsection{Local Rings at Stalks}

\begin{lstlisting}
def Spec.locallyRingedSpaceObj (R : CommRingCat.{u}) : LocallyRingedSpace :=
  { toSheafedSpace := Spec.sheafedSpaceObj R
    localRing := fun x => by
      exact (structureSheaf R).isUnit_res_basicOpen (R := R) ‚ü®x, rfl‚ü© }
\end{lstlisting}

\textbf{Natural Language:} The spectrum becomes a locally ringed space by verifying that the stalk at each point is indeed a local ring. This follows from the fundamental property of the structure sheaf that stalks are localizations at prime ideals.

\subsection{Stalk Maps and Locality}

\begin{lstlisting}
theorem stalkMap_toStalk {R S : CommRingCat.{u}} (f : R ‚ü∂ S) (p : PrimeSpectrum S) :
  StructureSheaf.stalkIso S p ‚â´
  (Spec.sheafedSpaceMap f).c.app (op (PrimeSpectrum.basicOpen ‚ä§)) ‚â´
  (StructureSheaf.stalkIso R (PrimeSpectrum.comap f.hom p)).inv =
  CommRingCat.ofHom (Localization.localRingHom _ _ f.hom rfl)
\end{lstlisting}

\textbf{Natural Language:} The induced maps on stalks are exactly the localization maps. This shows that morphisms of locally ringed spaces induced by ring homomorphisms have the correct local behavior.

\subsection{Morphisms of Locally Ringed Spaces}

\begin{lstlisting}
def Spec.locallyRingedSpaceMap {R S : CommRingCat.{u}} (f : R ‚ü∂ S) :
    Spec.locallyRingedSpaceObj S ‚ü∂ Spec.locallyRingedSpaceObj R :=
  { toSheafedSpaceHom := Spec.sheafedSpaceMap f
    isLocalAtTarget := fun x => by
      -- Proof that stalk maps are local ring homomorphisms
      -- ... }
\end{lstlisting}

\textbf{Natural Language:} A ring homomorphism induces a morphism of locally ringed spaces, where the key additional property is that the induced stalk maps are local ring homomorphisms.

\subsection{The Main Functor}

\begin{lstlisting}
def Spec.toLocallyRingedSpace : CommRingCat.{u}·µí·µñ ‚•§ LocallyRingedSpace where
  obj R := Spec.locallyRingedSpaceObj (unop R)
  map f := Spec.locallyRingedSpaceMap f.unop
\end{lstlisting}

\textbf{Natural Language:} This is the main result: a contravariant functor from commutative rings to locally ringed spaces. This functor is the foundation for defining schemes.

\section{The Spec-Œì Relationship}

\subsection{Natural Transformation to Global Sections}

\begin{lstlisting}
def toSpecŒì (R : CommRingCat.{u}) : R ‚ü∂ Œì.obj (op (Spec.toLocallyRingedSpace.obj (op R))) :=
  StructureSheaf.toOpen R ‚ä§

instance isIso_toSpecŒì (R : CommRingCat.{u}) : IsIso (toSpecŒì R)
\end{lstlisting}

\textbf{Natural Language:} There is a natural isomorphism between any commutative ring $R$ and the global sections of $\mathrm{Spec}(R)$. This is a fundamental relationship that will be part of the adjunction between $\Gamma$ and $\mathrm{Spec}$.

\subsection{Naturality}

\begin{lstlisting}
theorem Spec_Œì_naturality {R S : CommRingCat.{u}} (f : R ‚ü∂ S) :
  toSpecŒì R ‚â´ Œì.map (Spec.toLocallyRingedSpace.map f.op).op = f
\end{lstlisting}

\textbf{Natural Language:} The isomorphisms between rings and their spectra's global sections are natural with respect to ring homomorphisms. This naturality is crucial for establishing the adjunction.

\subsection{Identity Natural Transformation}

\begin{lstlisting}
def LocallyRingedSpace.SpecŒìIdentity : Spec.toLocallyRingedSpace.rightOp ‚ãô Œì ‚âÖ ùü≠ _ :=
  asIso
    { app := toSpecŒì
      naturality := Spec_Œì_naturality }
\end{lstlisting}

\textbf{Natural Language:} The collection of all these natural isomorphisms forms a natural isomorphism between the composite functor $\mathrm{Spec} \circ \Gamma$ and the identity functor. This is one of the triangle identities needed for the adjunction.

\section{Localization Properties}

\subsection{Localization Maps}

\begin{lstlisting}
theorem Spec_map_localization_isIso (R : CommRingCat.{u}) (M : Submonoid R)
    [M.IsUnit] : IsIso (Spec.locallyRingedSpaceMap (CommRingCat.ofHom (algebraMap R (Localization M))))
\end{lstlisting}

\textbf{Natural Language:} When $M$ consists entirely of units in $R$, the localization map $R \to M^{-1}R$ is an isomorphism, and consequently the induced map on spectra is also an isomorphism. This captures the idea that "localizing by units does nothing."

\section{Pushforward and Pullback Properties}

\subsection{Pushforward to Stalks}

\begin{lstlisting}
def toPushforwardStalk : S ‚ü∂ (Spec.topMap f _* (structureSheaf S).1).stalk p :=
  toStalk S (PrimeSpectrum.comap f.hom p) ‚â´
  (Spec.topMap f _* (structureSheaf S).1).germ ‚ü®p, rfl‚ü©
\end{lstlisting}

\textbf{Natural Language:} There are canonical maps from a ring to the stalks of pushforward sheaves. This construction is fundamental for understanding how ring homomorphisms affect the local structure of spectra.

\subsection{Algebraic Structure}

\begin{lstlisting}
instance : Algebra R ((Spec.topMap f _* (structureSheaf S).1).stalk p) :=
  RingHom.toAlgebra (toPushforwardStalk f p)
\end{lstlisting}

\textbf{Natural Language:} The stalks of pushforward sheaves naturally carry algebra structures over the original ring. This provides an algebraic framework for understanding the geometric relationship between spectra.

\section{Module-Theoretic Aspects}

\subsection{Localized Modules}

\begin{lstlisting}
def toPushforwardStalkAlgHom :
  S ‚ü∂‚Çê[R] (Spec.topMap f _* (structureSheaf S).1).stalk p :=
  { toFun := toPushforwardStalk f p
    -- Algebra homomorphism properties ... }

instance isLocalizedModule_toPushforwardStalkAlgHom :
  IsLocalizedModule (Ideal.primeCompl p.asIdeal) (toPushforwardStalkAlgHom f p)
\end{lstlisting}

\textbf{Natural Language:} The stalks of pushforward sheaves are localized modules in a precise sense. This connects the geometric construction with the algebraic theory of localization, providing tools for computing stalks and understanding their properties.

\section{Conclusion}

The Spec functor construction in this file provides the essential bridge between commutative algebra and algebraic geometry. By building up the structure in stages (topological $\to$ sheafed $\to$ locally ringed spaces), the implementation is both modular and mathematically transparent.

The key insights captured are:
\begin{itemize}
\item Prime ideals correspond to points in geometric spaces
\item Ring homomorphisms induce geometric maps in the reverse direction
\item Local algebraic properties (like being a local ring) have geometric meanings
\item The spectrum construction preserves and reflects important algebraic information
\end{itemize}

This foundation enables the definition of schemes and the development of the full theory of algebraic geometry in Mathlib4.

\end{document}
