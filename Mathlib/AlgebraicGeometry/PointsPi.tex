\documentclass{article}
\input{unicode_preamble}

\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{geometry}
\geometry{margin=1in}

% Define colors for Lean syntax highlighting
\definecolor{leanKeyword}{RGB}{0, 0, 255}       % Blue for keywords
\definecolor{leanType}{RGB}{139, 0, 139}        % Dark magenta for types
\definecolor{leanString}{RGB}{0, 128, 0}        % Green for strings
\definecolor{leanComment}{RGB}{128, 128, 128}   % Gray for comments
\definecolor{leanDefinition}{RGB}{255, 140, 0}  % Dark orange for definitions

% Configure listings for Lean
\lstdefinelanguage{Lean}{
    keywords={def, theorem, lemma, example, axiom, class, instance, inductive, structure,
              variable, namespace, open, import, export, section, end, if, then, else,
              match, with, fun, let, have, show, by, where, do, return, for, in,
              variable, universe, noncomputable, partial, mutual, protected, private,
              unsafe, opaque, @[simp], @[inline], @[reducible], @[irreducible],
              attribute, set_option, notation, infixl, infixr, prefix, postfix,
              scoped, local, macro, syntax, elab, deriving, extends, mk},
    morekeys={Type, Prop, Sort, Nat, Int, Real, Bool, true, false, Unit, 
              List, Array, Option, some, none, Sum, Prod, Sigma, Pi,
              and, or, not, iff, exists, forall},
    sensitive=true,
    morecomment=[l]{--},
    morecomment=[s]{/-}{-/},
    morestring=[b]",
    morestring=[b]',
}

\lstset{
    language=Lean,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{leanKeyword}\bfseries,
    commentstyle=\color{leanComment}\itshape,
    stringstyle=\color{leanString},
    numberstyle=\tiny\color{gray},
    numbers=left,
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{white},
    frame=single,
    rulecolor=\color{black!30},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=2,
    captionpos=b,
    showstringspaces=false,
    literate={
        {Î±}{{$\alpha$}}1 {Î²}{{$\beta$}}1 {Î³}{{$\gamma$}}1 {Î´}{{$\delta$}}1
        {Îµ}{{$\varepsilon$}}1 {Î¶}{{$\zeta$}}1 {Î·}{{$\eta$}}1 {Î¸}{{$\theta$}}1
        {Î¹}{{$\iota$}}1 {Îº}{{$\kappa$}}1 {Î»}{{$\lambda$}}1 {Î¼}{{$\mu$}}1
        {Î½}{{$\nu$}}1 {Î¾}{{$\xi$}}1 {Ï€}{{$\pi$}}1 {Ï}{{$\rho$}}1
        {Ïƒ}{{$\sigma$}}1 {Ï„}{{$\tau$}}1 {Ï†}{{$\varphi$}}1 {Ï‡}{{$\chi$}}1
        {Ïˆ}{{$\psi$}}1 {Ï‰}{{$\omega$}}1 {Î“}{{$\Gamma$}}1 {Î”}{{$\Delta$}}1
        {Î˜}{{$\Theta$}}1 {Î›}{{$\Lambda$}}1 {Î£}{{$\Sigma$}}1 {Î¦}{{$\Phi$}}1
        {Î¨}{{$\Psi$}}1 {Î©}{{$\Omega$}}1
        {â†’}{{$\rightarrow$}}2 {â†}{{$\leftarrow$}}2 {âŸ¶}{{$\longrightarrow$}}2
        {â†”}{{$\leftrightarrow$}}2 {âŸ·}{{$\longleftrightarrow$}}2
        {â‰¤}{{$\leq$}}1 {â‰¥}{{$\geq$}}1 {â‰ }{{$\neq$}}1 {â‰ˆ}{{$\approx$}}1
        {â‰¡}{{$\equiv$}}1 {â‰…}{{$\cong$}}1 {â‰ƒ}{{$\simeq$}}1
        {âˆˆ}{{$\in$}}1 {âˆ‰}{{$\notin$}}1 {âŠ†}{{$\subseteq$}}1 {âŠ‡}{{$\supseteq$}}1
        {âŠ‚}{{$\subset$}}1 {âŠƒ}{{$\supset$}}1 {âˆª}{{$\cup$}}1 {âˆ©}{{$\cap$}}1
        {âˆ…}{{$\emptyset$}}1 {âˆ}{{$\infty$}}1 {âˆ‚}{{$\partial$}}1
        {âˆ€}{{$\forall$}}1 {âˆƒ}{{$\exists$}}1 {âˆ§}{{$\land$}}1 {âˆ¨}{{$\lor$}}1
        {Â¬}{{$\neg$}}1 {âŠ¤}{{$\top$}}1 {âŠ¥}{{$\bot$}}1
        {Ã—}{{$\times$}}1 {Â·}{{$\cdot$}}1 {âˆ˜}{{$\circ$}}1
        {âŠ—}{{$\otimes$}}1 {âŠ•}{{$\oplus$}}1 {âŠ™}{{$\odot$}}1
        {âˆ‘}{{$\sum$}}1 {âˆ}{{$\prod$}}1 {âˆ«}{{$\int$}}1
        {â‚€}{{$_0$}}1 {â‚}{{$_1$}}1 {â‚‚}{{$_2$}}1 {â‚ƒ}{{$_3$}}1 {â‚„}{{$_4$}}1
        {â‚…}{{$_5$}}1 {â‚†}{{$_6$}}1 {â‚‡}{{$_7$}}1 {â‚ˆ}{{$_8$}}1 {â‚‰}{{$_9$}}1
        {â‚™}{{$_n$}}1 {â‚˜}{{$_m$}}1 {áµ¢}{{$_i$}}1 {â±¼}{{$_j$}}1
        {â°}{{$^0$}}1 {Â¹}{{$^1$}}1 {Â²}{{$^2$}}1 {Â³}{{$^3$}}1 {â´}{{$^4$}}1
        {âµ}{{$^5$}}1 {â¶}{{$^6$}}1 {â·}{{$^7$}}1 {â¸}{{$^8$}}1 {â¹}{{$^9$}}1
        {â¿}{{$^n$}}1 {áµ}{{$^m$}}1 {â±}{{$^i$}}1
        {â„•}{{$\mathbb{N}$}}1 {â„¤}{{$\mathbb{Z}$}}1 {â„š}{{$\mathbb{Q}$}}1
        {â„}{{$\mathbb{R}$}}1 {â„‚}{{$\mathbb{C}$}}1
        {ğ’°}{{$\mathcal{U}$}}1 {ğ’±}{{$\mathcal{V}$}}1 {ğ’²}{{$\mathcal{W}$}}1
        {ğ’³}{{$\mathcal{X}$}}1 {ğ’´}{{$\mathcal{Y}$}}1 {ğ’µ}{{$\mathcal{Z}$}}1
        {ğ”¸}{{$\mathbb{A}$}}1 {ğ”¹}{{$\mathbb{B}$}}1 {ğ”½}{{$\mathbb{F}$}}1
        {ğ•‚}{{$\mathbb{K}$}}1 {ğ•Š}{{$\mathbb{S}$}}1
        {âŸ¨}{{$\langle$}}1 {âŸ©}{{$\rangle$}}1 {âŒŠ}{{$\lfloor$}}1 {âŒ‹}{{$\rfloor$}}1
        {âŒˆ}{{$\lceil$}}1 {âŒ‰}{{$\rceil$}}1
        {â»Â¹}{{$^{-1}$}}2 {â–¸}{{$\triangleright$}}1
    }
}

\title{Lean 4 Code: PointsPi}
\author{Mathlib4}
\date{\today}

\begin{document}
\maketitle

\section{Source Code}

The following is the Lean 4 source code from \texttt{PointsPi.lean}:

\begin{lstlisting}[language=Lean, caption={PointsPi.lean}]
/-
Copyright (c) 2024 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang
-/
import Mathlib.AlgebraicGeometry.Morphisms.Immersion

/-!

# `Î  Ráµ¢`-Points of Schemes

We show that the canonical map `X(Î  Ráµ¢) âŸ¶ Î  X(Ráµ¢)` (`AlgebraicGeometry.pointsPi`)
is injective and surjective under various assumptions

-/

open CategoryTheory Limits PrimeSpectrum

namespace AlgebraicGeometry

universe u v

variable {Î¹ : Type u} (R : Î¹ â†’ CommRingCat.{u})

lemma Ideal.span_eq_top_of_span_image_evalRingHom
    {Î¹} {R : Î¹ â†’ Type*} [âˆ€ i, CommRing (R i)] (s : Set (Î  i, R i))
    (hs : s.Finite) (hs' : âˆ€ i, Ideal.span (Pi.evalRingHom (R Â·) i '' s) = âŠ¤) :
    Ideal.span s = âŠ¤ := by
  simp only [Ideal.eq_top_iff_one, â† Subtype.range_val (s := s), â† Set.range_comp,
    Finsupp.mem_ideal_span_range_iff_exists_finsupp] at hs' âŠ¢
  choose f hf using hs'
  have : Fintype s := hs.fintype
  refine âŸ¨Finsupp.equivFunOnFinite.symm fun i x â†¦ f x i, ?_âŸ©
  ext i
  simpa [Finsupp.sum_fintype] using hf i

lemma eq_top_of_sigmaSpec_subset_of_isCompact
    (U : Spec(Î  i, R i).Opens) (V : Set Spec(Î  i, R i))
    (hV : â†‘(sigmaSpec R).opensRange âŠ† V)
    (hV' : IsCompact (X := Spec(Î  i, R i)) V)
    (hVU : V âŠ† U) : U = âŠ¤ := by
  obtain âŸ¨s, hsâŸ© := (PrimeSpectrum.isOpen_iff _).mp U.2
  obtain âŸ¨t, hts, ht, ht'âŸ© : âˆƒ t âŠ† s, t.Finite âˆ§ V âŠ† â‹ƒ i âˆˆ t, (basicOpen i).1 := by
    obtain âŸ¨t, htâŸ© := hV'.elim_finite_subcover
      (fun i : s â†¦ (basicOpen i.1).1) (fun _ â†¦ (basicOpen _).2)
      (by simpa [â† Set.compl_iInter, â† zeroLocus_iUnionâ‚‚ (Îº := (Â· âˆˆ s)), â† hs])
    exact âŸ¨t.map (Function.Embedding.subtype _), by simp, Finset.finite_toSet _, by simpa using htâŸ©
  replace ht' : V âŠ† (zeroLocus t)á¶œ := by
    simpa [â† Set.compl_iInter, â† zeroLocus_iUnionâ‚‚ (Îº := (Â· âˆˆ t))] using ht'
  have (i : _) : Ideal.span (Pi.evalRingHom (R Â·) i '' t) = âŠ¤ := by
    rw [â† zeroLocus_empty_iff_eq_top, zeroLocus_span, â† preimage_comap_zeroLocus,
      â† Set.compl_univ_iff, â† Set.preimage_compl, Set.preimage_eq_univ_iff]
    trans (Sigma.Î¹ _ i â‰« sigmaSpec R).opensRange.1
    Â· simp; rfl
    Â· rw [Scheme.Hom.opensRange_comp]
      exact (Set.image_subset_range _ _).trans (hV.trans ht')
  have : Ideal.span s = âŠ¤ := top_le_iff.mp
    ((Ideal.span_eq_top_of_span_image_evalRingHom _ ht this).ge.trans (Ideal.span_mono hts))
  simpa [â† zeroLocus_span s, zeroLocus_empty_iff_eq_top.mpr this] using hs

lemma eq_bot_of_comp_quotientMk_eq_sigmaSpec (I : Ideal (Î  i, R i))
    (f : (âˆ fun i â†¦ Spec (R i)) âŸ¶ Spec((Î  i, R i) â§¸ I))
    (hf : f â‰« Spec.map (CommRingCat.ofHom (Ideal.Quotient.mk I)) = sigmaSpec R) :
    I = âŠ¥ := by
  refine le_bot_iff.mp fun x hx â†¦ ?_
  ext i
  simpa [â† Category.assoc, Ideal.Quotient.eq_zero_iff_mem.mpr hx] using
    congr((Spec.preimage (Sigma.Î¹ (Spec <| R Â·) i â‰« $hf)).hom x).symm

/-- If `V` is a locally closed subscheme of `Spec (Î  Ráµ¢)` containing `âˆ Spec Ráµ¢`, then
`V = Spec (Î  Ráµ¢)`. -/
lemma isIso_of_comp_eq_sigmaSpec {V : Scheme}
    (f : (âˆ fun i â†¦ Spec (R i)) âŸ¶ V) (g : V âŸ¶ Spec(Î  i, R i))
    [IsImmersion g] [CompactSpace V]
    (hU' : f â‰« g = sigmaSpec R) : IsIso g := by
  have : g.coborderRange = âŠ¤ := by
    apply eq_top_of_sigmaSpec_subset_of_isCompact (hVU := subset_coborder)
    Â· simpa only [â† hU'] using Set.range_comp_subset_range f.base g.base
    Â· exact isCompact_range g.base.hom.2
  have : IsClosedImmersion g := by
    have : IsIso g.coborderRange.Î¹ := by rw [this, â† Scheme.topIso_hom]; infer_instance
    rw [â† g.liftCoborder_Î¹]
    infer_instance
  obtain âŸ¨I, e, rflâŸ© := IsClosedImmersion.Spec_iff.mp this
  obtain rfl := eq_bot_of_comp_quotientMk_eq_sigmaSpec R I (f â‰« e.hom) (by rwa [Category.assoc])
  convert_to IsIso (e.hom â‰« Spec.map (RingEquiv.quotientBot _).toCommRingCatIso.inv)
  infer_instance

variable (X : Scheme)

/-- The canonical map `X(Î  Ráµ¢) âŸ¶ Î  X(Ráµ¢)`.
This is injective if `X` is quasi-separated, surjective if `X` is affine,
or if `X` is compact and each `Ráµ¢` is local. -/
noncomputable
def pointsPi : (Spec(Î  i, R i) âŸ¶ X) â†’ Î  i, Spec (R i) âŸ¶ X :=
  fun f i â†¦ Spec.map (CommRingCat.ofHom (Pi.evalRingHom (R Â·) i)) â‰« f

lemma pointsPi_injective [QuasiSeparatedSpace X] : Function.Injective (pointsPi R X) := by
  rintro f g e
  have := isIso_of_comp_eq_sigmaSpec R (V := equalizer f g)
    (equalizer.lift (sigmaSpec R) (by ext1 i; simpa using congr_fun e i))
    (equalizer.Î¹ f g) (by simp)
  rw [â† cancel_epi (equalizer.Î¹ f g), equalizer.condition]

lemma pointsPi_surjective_of_isAffine [IsAffine X] : Function.Surjective (pointsPi R X) := by
  rintro f
  refine âŸ¨Spec.map (CommRingCat.ofHom
    (Pi.ringHom fun i â†¦ (Spec.preimage (f i â‰« X.isoSpec.hom)).1)) â‰« X.isoSpec.inv, ?_âŸ©
  ext i : 1
  simp only [pointsPi, â† Spec.map_comp_assoc, Iso.comp_inv_eq]
  exact Spec.map_preimage _

lemma pointsPi_surjective [CompactSpace X] [âˆ€ i, IsLocalRing (R i)] :
    Function.Surjective (pointsPi R X) := by
  intro f
  let ğ’° : X.OpenCover := X.affineCover.finiteSubcover
  have (i : _) : IsAffine (ğ’°.obj i) := isAffine_Spec _
  have (i : _) : âˆƒ j, Set.range (f i).base âŠ† (ğ’°.map j).opensRange := by
    refine âŸ¨ğ’°.f ((f i).base (IsLocalRing.closedPoint (R i))), ?_âŸ©
    rintro _ âŸ¨x, rflâŸ©
    exact ((IsLocalRing.specializes_closedPoint x).map (f i).base.hom.2).mem_open
      (ğ’°.map _).opensRange.2 (ğ’°.covers _)
  choose j hj using this
  have (jâ‚€ : _) := pointsPi_surjective_of_isAffine (Î¹ := { i // j i = jâ‚€ }) (R Â·) (ğ’°.obj jâ‚€)
    (fun i â†¦ IsOpenImmersion.lift (ğ’°.map jâ‚€) (f i.1) (by rcases i with âŸ¨i, rflâŸ©; exact hj i))
  choose g hg using this
  simp_rw [funext_iff, pointsPi] at hg
  let R' (jâ‚€) := CommRingCat.of (Î  i : { i // j i = jâ‚€ }, R i)
  let e : (Î  i, R i) â‰ƒ+* Î  jâ‚€, R' jâ‚€ :=
  { toFun f _ i := f i
    invFun f i := f _ âŸ¨i, rflâŸ©
    right_inv _ := funextâ‚‚ fun jâ‚€ i â†¦ by rcases i with âŸ¨i, rflâŸ©; rfl
    map_mul' _ _ := rfl
    map_add' _ _ := rfl }
  refine âŸ¨Spec.map (CommRingCat.ofHom e.symm.toRingHom) â‰« inv (sigmaSpec R') â‰«
    Sigma.desc fun jâ‚€ â†¦ g jâ‚€ â‰« ğ’°.map jâ‚€, ?_âŸ©
  ext i : 1
  have : (Pi.evalRingHom (R Â·) i).comp e.symm.toRingHom =
    (Pi.evalRingHom _ âŸ¨i, rflâŸ©).comp (Pi.evalRingHom (R' Â·) (j i)) := rfl
  rw [pointsPi, â† Spec.map_comp_assoc, â† CommRingCat.ofHom_comp, this, CommRingCat.ofHom_comp,
    Spec.map_comp_assoc, â† Î¹_sigmaSpec R', Category.assoc, IsIso.hom_inv_id_assoc,
    Sigma.Î¹_desc, â† Category.assoc, hg, IsOpenImmersion.lift_fac]

end AlgebraicGeometry

\end{lstlisting}

\end{document}
