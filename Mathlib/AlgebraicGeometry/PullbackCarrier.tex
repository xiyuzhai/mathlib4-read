\documentclass{article}
\usepackage[utf8]{inputenc}
% Better Unicode support
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{textcomp}
\usepackage{newunicodechar}
\usepackage{stmaryrd}

% Define Unicode characters
\newunicodechar{↦}{\ensuremath{\mapsto}}
\newunicodechar{⟨}{\ensuremath{\langle}}
\newunicodechar{⟩}{\ensuremath{\rangle}}
\newunicodechar{‹}{\ensuremath{\langle}}
\newunicodechar{›}{\ensuremath{\rangle}}
\newunicodechar{→}{\ensuremath{\to}}
\newunicodechar{⟶}{\ensuremath{\longrightarrow}}
\newunicodechar{↪}{\ensuremath{\hookrightarrow}}
\newunicodechar{≅}{\ensuremath{\cong}}
\newunicodechar{≃}{\ensuremath{\simeq}}
\newunicodechar{⊆}{\ensuremath{\subseteq}}
\newunicodechar{⊇}{\ensuremath{\supseteq}}
\newunicodechar{∈}{\ensuremath{\in}}
\newunicodechar{∉}{\ensuremath{\notin}}
\newunicodechar{∃}{\ensuremath{\exists}}
\newunicodechar{∀}{\ensuremath{\forall}}
\newunicodechar{∧}{\ensuremath{\land}}
\newunicodechar{∨}{\ensuremath{\lor}}
\newunicodechar{≤}{\ensuremath{\leq}}
\newunicodechar{≥}{\ensuremath{\geq}}
\newunicodechar{≠}{\ensuremath{\neq}}
\newunicodechar{≡}{\ensuremath{\equiv}}
\newunicodechar{≈}{\ensuremath{\approx}}
\newunicodechar{∞}{\ensuremath{\infty}}
\newunicodechar{∅}{\ensuremath{\emptyset}}
\newunicodechar{∪}{\ensuremath{\cup}}
\newunicodechar{∩}{\ensuremath{\cap}}
\newunicodechar{×}{\ensuremath{\times}}
\newunicodechar{⊗}{\ensuremath{\otimes}}
\newunicodechar{⊕}{\ensuremath{\oplus}}
\newunicodechar{⊤}{\ensuremath{\top}}
\newunicodechar{⊥}{\ensuremath{\bot}}
\newunicodechar{∘}{\ensuremath{\circ}}
\newunicodechar{∂}{\ensuremath{\partial}}
\newunicodechar{∇}{\ensuremath{\nabla}}
\newunicodechar{∫}{\ensuremath{\int}}
\newunicodechar{∑}{\ensuremath{\sum}}
\newunicodechar{∏}{\ensuremath{\prod}}
\newunicodechar{⋯}{\ensuremath{\cdots}}
\newunicodechar{⨆}{\ensuremath{\bigsqcup}}
\newunicodechar{⧸}{\ensuremath{/}}
\newunicodechar{≫}{\ensuremath{\gg}}
\newunicodechar{≪}{\ensuremath{\ll}}
\newunicodechar{⥤}{\ensuremath{\Rightarrow}}
\newunicodechar{⋙}{\ensuremath{\ggg}}
\newunicodechar{≌}{\ensuremath{\fallingdotseq}}
\newunicodechar{↑}{\ensuremath{\uparrow}}
\newunicodechar{↓}{\ensuremath{\downarrow}}
\newunicodechar{⇒}{\ensuremath{\Rightarrow}}
\newunicodechar{⇐}{\ensuremath{\Leftarrow}}
\newunicodechar{⇔}{\ensuremath{\Leftrightarrow}}
\newunicodechar{↔}{\ensuremath{\leftrightarrow}}
\newunicodechar{⊢}{\ensuremath{\vdash}}
\newunicodechar{⊣}{\ensuremath{\dashv}}
\newunicodechar{⊓}{\ensuremath{\sqcap}}
\newunicodechar{⊔}{\ensuremath{\sqcup}}
\newunicodechar{⋮}{\ensuremath{\vdots}}
\newunicodechar{⋱}{\ensuremath{\ddots}}
\newunicodechar{√}{\ensuremath{\sqrt{}}}
\newunicodechar{∝}{\ensuremath{\propto}}
\newunicodechar{∼}{\ensuremath{\sim}}
\newunicodechar{≲}{\ensuremath{\lesssim}}
\newunicodechar{≳}{\ensuremath{\gtrsim}}
\newunicodechar{⊂}{\ensuremath{\subset}}
\newunicodechar{⊃}{\ensuremath{\supset}}
\newunicodechar{⊊}{\ensuremath{\subsetneq}}
\newunicodechar{⊋}{\ensuremath{\supsetneq}}
\newunicodechar{∖}{\ensuremath{\setminus}}
\newunicodechar{∣}{\ensuremath{\mid}}
\newunicodechar{∤}{\ensuremath{\nmid}}
\newunicodechar{∥}{\ensuremath{\parallel}}
\newunicodechar{∦}{\ensuremath{\nparallel}}
\newunicodechar{⊙}{\ensuremath{\odot}}
\newunicodechar{⊖}{\ensuremath{\ominus}}
\newunicodechar{⊘}{\ensuremath{\oslash}}
\newunicodechar{⊚}{\ensuremath{\circledcirc}}
\newunicodechar{⊛}{\ensuremath{\circledast}}
\newunicodechar{⊝}{\ensuremath{\circleddash}}
\newunicodechar{◯}{\ensuremath{\bigcirc}}
\newunicodechar{⬝}{\ensuremath{\cdot}}
\newunicodechar{▸}{\ensuremath{\blacktriangleright}}

% Greek letters
\newunicodechar{α}{\ensuremath{\alpha}}
\newunicodechar{β}{\ensuremath{\beta}}
\newunicodechar{γ}{\ensuremath{\gamma}}
\newunicodechar{δ}{\ensuremath{\delta}}
\newunicodechar{ε}{\ensuremath{\varepsilon}}
\newunicodechar{ζ}{\ensuremath{\zeta}}
\newunicodechar{η}{\ensuremath{\eta}}
\newunicodechar{θ}{\ensuremath{\theta}}
\newunicodechar{ι}{\ensuremath{\iota}}
\newunicodechar{κ}{\ensuremath{\kappa}}
\newunicodechar{λ}{\ensuremath{\lambda}}
\newunicodechar{μ}{\ensuremath{\mu}}
\newunicodechar{ν}{\ensuremath{\nu}}
\newunicodechar{ξ}{\ensuremath{\xi}}
\newunicodechar{π}{\ensuremath{\pi}}
\newunicodechar{ρ}{\ensuremath{\rho}}
\newunicodechar{σ}{\ensuremath{\sigma}}
\newunicodechar{τ}{\ensuremath{\tau}}
\newunicodechar{φ}{\ensuremath{\varphi}}
\newunicodechar{χ}{\ensuremath{\chi}}
\newunicodechar{ψ}{\ensuremath{\psi}}
\newunicodechar{ω}{\ensuremath{\omega}}
\newunicodechar{Γ}{\ensuremath{\Gamma}}
\newunicodechar{Δ}{\ensuremath{\Delta}}
\newunicodechar{Σ}{\ensuremath{\Sigma}}
\newunicodechar{Π}{\ensuremath{\Pi}}
\newunicodechar{Ω}{\ensuremath{\Omega}}

% Superscripts and subscripts  
\newunicodechar{⁻}{\ensuremath{^{-}}}
\newunicodechar{¹}{\ensuremath{^{1}}}
\newunicodechar{²}{\ensuremath{^{2}}}
\newunicodechar{³}{\ensuremath{^{3}}}
\newunicodechar{⁴}{\ensuremath{^{4}}}
\newunicodechar{⁵}{\ensuremath{^{5}}}
\newunicodechar{⁶}{\ensuremath{^{6}}}
\newunicodechar{⁷}{\ensuremath{^{7}}}
\newunicodechar{⁸}{\ensuremath{^{8}}}
\newunicodechar{⁹}{\ensuremath{^{9}}}
\newunicodechar{⁰}{\ensuremath{^{0}}}
\newunicodechar{ⁿ}{\ensuremath{^{n}}}
\newunicodechar{ᵒ}{\ensuremath{^{o}}}
\newunicodechar{ᵖ}{\ensuremath{^{p}}}
\newunicodechar{ᵐ}{\ensuremath{^{m}}}
\newunicodechar{ᵢ}{\ensuremath{_{i}}}
\newunicodechar{₀}{\ensuremath{_{0}}}
\newunicodechar{₁}{\ensuremath{_{1}}}
\newunicodechar{₂}{\ensuremath{_{2}}}
\newunicodechar{₃}{\ensuremath{_{3}}}
\newunicodechar{₄}{\ensuremath{_{4}}}
\newunicodechar{₅}{\ensuremath{_{5}}}
\newunicodechar{₆}{\ensuremath{_{6}}}
\newunicodechar{₇}{\ensuremath{_{7}}}
\newunicodechar{₈}{\ensuremath{_{8}}}
\newunicodechar{₉}{\ensuremath{_{9}}}
\newunicodechar{ₙ}{\ensuremath{_{n}}}
\newunicodechar{ₘ}{\ensuremath{_{m}}}

% Mathematical alphabets
\newunicodechar{𝒰}{\ensuremath{\mathcal{U}}}
\newunicodechar{𝒱}{\ensuremath{\mathcal{V}}}
\newunicodechar{𝒲}{\ensuremath{\mathcal{W}}}
\newunicodechar{𝒳}{\ensuremath{\mathcal{X}}}
\newunicodechar{𝒴}{\ensuremath{\mathcal{Y}}}
\newunicodechar{𝒵}{\ensuremath{\mathcal{Z}}}
\newunicodechar{𝓐}{\ensuremath{\mathcal{A}}}
\newunicodechar{𝓑}{\ensuremath{\mathcal{B}}}
\newunicodechar{𝓒}{\ensuremath{\mathcal{C}}}
\newunicodechar{𝓓}{\ensuremath{\mathcal{D}}}
\newunicodechar{𝓔}{\ensuremath{\mathcal{E}}}
\newunicodechar{𝓕}{\ensuremath{\mathcal{F}}}
\newunicodechar{𝓖}{\ensuremath{\mathcal{G}}}
\newunicodechar{𝓗}{\ensuremath{\mathcal{H}}}
\newunicodechar{𝓘}{\ensuremath{\mathcal{I}}}
\newunicodechar{𝓙}{\ensuremath{\mathcal{J}}}
\newunicodechar{𝓚}{\ensuremath{\mathcal{K}}}
\newunicodechar{𝓛}{\ensuremath{\mathcal{L}}}
\newunicodechar{𝓜}{\ensuremath{\mathcal{M}}}
\newunicodechar{𝓝}{\ensuremath{\mathcal{N}}}
\newunicodechar{𝓞}{\ensuremath{\mathcal{O}}}
\newunicodechar{𝓟}{\ensuremath{\mathcal{P}}}
\newunicodechar{𝓠}{\ensuremath{\mathcal{Q}}}
\newunicodechar{𝓡}{\ensuremath{\mathcal{R}}}
\newunicodechar{𝓢}{\ensuremath{\mathcal{S}}}
\newunicodechar{𝓣}{\ensuremath{\mathcal{T}}}
\newunicodechar{𝟙}{\ensuremath{\mathbb{1}}}
\newunicodechar{𝟘}{\ensuremath{\mathbb{0}}}
\newunicodechar{ℕ}{\ensuremath{\mathbb{N}}}
\newunicodechar{ℤ}{\ensuremath{\mathbb{Z}}}
\newunicodechar{ℚ}{\ensuremath{\mathbb{Q}}}
\newunicodechar{ℝ}{\ensuremath{\mathbb{R}}}
\newunicodechar{ℂ}{\ensuremath{\mathbb{C}}}


\usepackage{amsmath, amsthm, amssymb}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{geometry}
\geometry{margin=1in}

% Define colors for Lean syntax highlighting
\definecolor{leanKeyword}{RGB}{0, 0, 255}       % Blue for keywords
\definecolor{leanType}{RGB}{139, 0, 139}        % Dark magenta for types
\definecolor{leanString}{RGB}{0, 128, 0}        % Green for strings
\definecolor{leanComment}{RGB}{128, 128, 128}   % Gray for comments
\definecolor{leanDefinition}{RGB}{255, 140, 0}  % Dark orange for definitions
\definecolor{leanAttribute}{RGB}{255, 20, 147}  % Deep pink for attributes
\definecolor{leanBackground}{RGB}{250, 250, 250} % Light gray background

% Define Lean language for listings
\lstdefinelanguage{Lean}{
  % Keywords
  morekeywords=[1]{def, theorem, lemma, instance, class, structure, inductive,
    axiom, constant, variable, namespace, section, noncomputable, protected,
    private, abbrev, example, open, attribute, local, mutual, by, where,
    extends, deriving, end, import, prelude, theory, with, without, using,
    match, if, then, else, fun, have, show, from, let, in, do, begin, calc},
  % Types and Type constructors
  morekeywords=[2]{Type, Prop, Sort, Nat, Int, Bool, String, Char, List,
    Option, Unit, Prod, Sum, Sigma, Subtype, Set, Scheme, CommRingCat,
    AffineScheme, Opens, IsAffine, IsAffineOpen, Spec, Category, Functor,
    Iso, IsIso, CompactSpace, IsCompact, IsOpenImmersion, Equiv, Hom,
    pullback, PullbackCone, Triplet, residueField, TensorProduct},
  % Tactics (if they appear)
  morekeywords=[3]{simp, rfl, exact, apply, intro, cases, induction, refl,
    constructor, assumption, contradiction, trivial, sorry, admit, rw,
    convert, infer_instance, ext, rintro, obtain, refine, dsimp},
  % Sensitive
  sensitive=true,
  % Comments
  morecomment=[l]{--},
  morecomment=[n]{/-}{-/},
  % Strings
  morestring=[b]",
  % Style
  keywordstyle=[1]\color{leanKeyword}\bfseries,
  keywordstyle=[2]\color{leanType}\bfseries,
  keywordstyle=[3]\color{leanDefinition}\itshape,
  commentstyle=\color{leanComment}\itshape,
  stringstyle=\color{leanString},
  % Highlight attributes
  moredelim=[is][\color{leanAttribute}]{@[}{]},
  moredelim=[is][\color{leanAttribute}]{\#[}{]},
}

\lstset{
  language=Lean,
  basicstyle=\ttfamily\small,
  backgroundcolor=\color{leanBackground},
  breaklines=true,
  frame=single,
  framerule=0.5pt,
  rulecolor=\color{gray!30},
  numbers=left,
  numberstyle=\tiny\color{gray},
  numbersep=5pt,
  showstringspaces=false,
  captionpos=b,
  xleftmargin=10pt,
  framexleftmargin=10pt,
  }


           {$^{-1}$}{{$^{-1}$}}2
           {$^{op}$}{{$^{op}$}}2

           {$\mathcal{U}$}{{$\mathcal{U}$}}1
           {$\mathbb{1}$}{{$\mathbb{1}$}}

           {:=}{{$\mathrel{:=}$}}2

}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{instance}{Instance}

\title{Pullback Carrier Spaces in Mathlib4\\
\large A Companion to \texttt{PullbackCarrier.lean}}
\author{}
\date{}

\begin{document}
\maketitle

\section{Introduction}

This document provides a natural language companion to the \texttt{PullbackCarrier.lean} file in Mathlib4. The file describes the underlying topological space of fiber products (pullbacks) of schemes, giving an explicit bijective correspondence between points of $X \times_S Y$ and certain algebraic data involving residue field tensor products.

\section{The Triplet Structure}

\subsection{Definition of Triplets}

\begin{lstlisting}
structure Triplet {X Y S : Scheme.{u}} (f : X ⟶ S) (g : Y ⟶ S) where
  x : X
  y : Y
  s : S
  hx : f.base x = s
  hy : g.base y = s
\end{lstlisting}

\textbf{Natural Language:} A triplet over morphisms $f: X \to S$ and $g: Y \to S$ consists of points $x \in X$, $y \in Y$, and $s \in S$ such that $f(x) = s = g(y)$. This captures the idea that $x$ and $y$ "meet" at the point $s$ in the base scheme.

\subsection{Convenient Constructor}

\begin{lstlisting}
def mk' (x : X) (y : Y) (h : f.base x = g.base y) : Triplet f g where
  x := x
  y := y
  s := g.base y
  hx := h
  hy := rfl
\end{lstlisting}

\textbf{Natural Language:} Given points $x \in X$ and $y \in Y$ such that $f(x) = g(y)$, we can construct the corresponding triplet with $s = g(y)$ as the common image point.

\section{Tensor Product Construction}

\subsection{Residue Field Tensor Product}

\begin{lstlisting}
def tensor (T : Triplet f g) : CommRingCat :=
  pushout ((S.residueFieldCongr T.hx).inv ≫ f.residueFieldMap T.x)
    ((S.residueFieldCongr T.hy).inv ≫ g.residueFieldMap T.y)
\end{lstlisting}

\textbf{Natural Language:} For a triplet $(x, y, s)$ with $f(x) = s = g(y)$, we define the tensor product $\kappa(x) \otimes_{\kappa(s)} \kappa(y)$ as the pushout of the residue field maps. This captures the algebraic structure of the "intersection" of $x$ and $y$ over $s$.

\subsection{Nontriviality}

\begin{lstlisting}
instance (T : Triplet f g) : Nontrivial T.tensor
\end{lstlisting}

\textbf{Natural Language:} The tensor product $\kappa(x) \otimes_{\kappa(s)} \kappa(y)$ is always nontrivial, reflecting the fact that residue fields are fields and their tensor products over fields are nontrivial.

\section{Canonical Maps}

\subsection{Inclusion Maps}

\begin{lstlisting}
def tensorInl (T : Triplet f g) : X.residueField T.x ⟶ T.tensor := pushout.inl _ _
def tensorInr (T : Triplet f g) : Y.residueField T.y ⟶ T.tensor := pushout.inr _ _
\end{lstlisting}

\textbf{Natural Language:} These are the canonical inclusions $\kappa(x) \to \kappa(x) \otimes_{\kappa(s)} \kappa(y)$ and $\kappa(y) \to \kappa(x) \otimes_{\kappa(s)} \kappa(y)$ into the tensor product.

\subsection{Spec Map to Pullback}

\begin{lstlisting}
def SpecTensorTo : Spec T.tensor ⟶ pullback f g :=
  pullback.lift (Spec.map T.tensorInl ≫ X.fromSpecResidueField T.x)
    (Spec.map T.tensorInr ≫ Y.fromSpecResidueField T.y)
    (Spec_map_tensorInl_fromSpecResidueField _)
\end{lstlisting}

\textbf{Natural Language:} This constructs the natural morphism from $\mathrm{Spec}(\kappa(x) \otimes_{\kappa(s)} \kappa(y))$ to the pullback $X \times_S Y$, using the universal property of pullbacks.

\section{Point Correspondence}

\subsection{From Pullback Points to Triplets}

\begin{lstlisting}
def ofPoint (t : ↑(pullback f g)) : Triplet f g :=
  ⟨(pullback.fst f g).base t, (pullback.snd f g).base t, _, rfl,
    congr((Scheme.Hom.toLRSHom $(pullback.condition (f := f) (g := g))).base t).symm⟩
\end{lstlisting}

\textbf{Natural Language:} Given a point $t$ in the pullback $X \times_S Y$, we obtain a triplet by taking its projections to $X$ and $Y$, along with the common image in $S$.

\subsection{Tensor Product Map}

\begin{lstlisting}
def ofPointTensor (t : ↑(pullback f g)) :
    (Triplet.ofPoint t).tensor ⟶ (pullback f g).residueField t
\end{lstlisting}

\textbf{Natural Language:} For each point $t$ in the pullback, there's a canonical map from the tensor product of residue fields to the residue field at $t$.

\section{Main Bijection Theorem}

\subsection{The Carrier Equivalence}

\begin{lstlisting}
def carrierEquiv : ↑(pullback f g) ≃ Σ T : Triplet f g, Spec T.tensor where
  toFun t := ⟨.ofPoint t, SpecOfPoint t⟩
  invFun T := T.1.SpecTensorTo.base T.2
  left_inv := SpecTensorTo_SpecOfPoint
  right_inv := by
    intro ⟨T, p⟩
    apply carrierEquiv_eq_iff.mpr
    use T.ofPoint_SpecTensorTo p
    ...
\end{lstlisting}

\textbf{Natural Language:} This is the main theorem: points of $X \times_S Y$ bijectively correspond to pairs $(T, p)$ where $T = (x, y, s)$ is a triplet with $f(x) = s = g(y)$, and $p$ is a prime ideal of $\kappa(x) \otimes_{\kappa(s)} \kappa(y)$.

\subsection{Geometric Interpretation}

The bijection has the following geometric interpretation:
\begin{itemize}
\item A point in $X \times_S Y$ determines points $x \in X$, $y \in Y$ mapping to the same $s \in S$
\item The "local behavior" at this point is captured by a prime ideal in the tensor product of residue fields
\item This tensor product encodes how the local rings at $x$ and $y$ interact over the local ring at $s$
\end{itemize}

\section{Existence of Preimages}

\subsection{Main Existence Theorem}

\begin{lstlisting}
lemma exists_preimage_pullback (x : X) (y : Y) (h : f.base x = g.base y) :
    ∃ z : ↑(pullback f g),
    (pullback.fst f g).base z = x ∧ (pullback.snd f g).base z = y
\end{lstlisting}

\textbf{Natural Language:} For any points $x \in X$ and $y \in Y$ such that $f(x) = g(y)$, there exists a point in the pullback $X \times_S Y$ that maps to $x$ and $y$ respectively. This shows that the map from the pullback to the fiber product of underlying topological spaces is surjective.

\subsection{Characterization of Empty Pullbacks}

\begin{lstlisting}
lemma _root_.AlgebraicGeometry.Scheme.isEmpty_pullback_iff {f : X ⟶ S} {g : Y ⟶ S} :
    IsEmpty ↑(Limits.pullback f g) ↔ Disjoint (Set.range f.base) (Set.range g.base)
\end{lstlisting}

\textbf{Natural Language:} The pullback $X \times_S Y$ is empty if and only if the images of $f$ and $g$ in $S$ are disjoint. This provides a topological criterion for when fibered products are empty.

\section{Range Characterizations}

\subsection{Range of Projections}

\begin{lstlisting}
lemma range_fst : Set.range (pullback.fst f g).base = f.base ⁻¹' Set.range g.base
lemma range_snd : Set.range (pullback.snd f g).base = g.base ⁻¹' Set.range f.base
\end{lstlisting}

\textbf{Natural Language:} The first projection has image equal to the preimage under $f$ of the image of $g$, and vice versa. This characterizes exactly which points in $X$ and $Y$ appear in the pullback.

\subsection{Composition Ranges}

\begin{lstlisting}
lemma range_fst_comp :
    Set.range (pullback.fst f g ≫ f).base = Set.range f.base ∩ Set.range g.base
\end{lstlisting}

\textbf{Natural Language:} The image of the composed map through $f$ (or $g$) equals the intersection of the images of $f$ and $g$ in $S$.

\section{Pullback Maps}

\subsection{Range Under Pullback Maps}

\begin{lstlisting}
lemma range_map {X' Y' S' : Scheme.{u}} (f' : X' ⟶ S') (g' : Y' ⟶ S') (i₁ : X ⟶ X')
    (i₂ : Y ⟶ Y') (i₃ : S ⟶ S') (e₁ : f ≫ i₃ = i₁ ≫ f')
    (e₂ : g ≫ i₃ = i₂ ≫ g') [Mono i₃] :
    Set.range (pullback.map f g f' g' i₁ i₂ i₃ e₁ e₂).base =
      (pullback.fst f' g').base ⁻¹' Set.range i₁.base ∩
        (pullback.snd f' g').base ⁻¹' Set.range i₂.base
\end{lstlisting}

\textbf{Natural Language:} For compatible morphisms forming a map between pullbacks, the image of the pullback map has a precise description in terms of preimages under the component morphisms.

\section{Stability Properties}

\subsection{Surjectivity is Stable Under Base Change}

\begin{lstlisting}
instance : MorphismProperty.IsStableUnderBaseChange @Surjective
\end{lstlisting}

\textbf{Natural Language:} If $g: Y \to S$ is surjective, then for any $f: X \to S$, the first projection $X \times_S Y \to X$ is also surjective. This is a fundamental stability property in algebraic geometry.

\section{Applications and Importance}

The explicit description of pullback carrier spaces provided in this file has several important applications:

\subsection{Geometric Understanding}
\begin{itemize}
\item Provides a concrete way to understand points in fiber products
\item Shows how local algebraic data (residue fields) determines global geometric properties
\item Gives explicit criteria for when fiber products are empty or have certain properties
\end{itemize}

\subsection{Computational Aspects}
\begin{itemize}
\item Allows explicit computation of points in pullbacks
\item Provides algorithms for checking surjectivity and other properties
\item Gives concrete descriptions of ranges and preimages
\end{itemize}

\subsection{Theoretical Foundation}
\begin{itemize}
\item Establishes the connection between scheme-theoretic and topological fiber products
\item Provides the foundation for more advanced constructions in algebraic geometry
\item Shows how categorical pullbacks relate to concrete geometric objects
\end{itemize}

\section{Conclusion}

The \texttt{PullbackCarrier.lean} file provides a complete description of the underlying topological spaces of scheme-theoretic pullbacks. The main achievement is the bijective correspondence between points of $X \times_S Y$ and pairs of triplets $(x, y, s)$ with prime ideals in tensor products of residue fields. This bridges the abstract categorical definition of pullbacks with concrete, computable descriptions of their points, making the theory of fiber products in algebraic geometry both rigorous and practical.

\end{document}