\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{geometry}
\geometry{margin=1in}

% Define colors for Lean syntax highlighting
\definecolor{leanKeyword}{RGB}{0, 0, 255}       % Blue for keywords
\definecolor{leanType}{RGB}{139, 0, 139}        % Dark magenta for types
\definecolor{leanString}{RGB}{0, 128, 0}        % Green for strings
\definecolor{leanComment}{RGB}{128, 128, 128}   % Gray for comments
\definecolor{leanDefinition}{RGB}{255, 140, 0}  % Dark orange for definitions
\definecolor{leanAttribute}{RGB}{255, 20, 147}  % Deep pink for attributes
\definecolor{leanBackground}{RGB}{250, 250, 250} % Light gray background

% Define Lean language for listings
\lstdefinelanguage{Lean}{
  % Keywords
  morekeywords=[1]{def, theorem, lemma, instance, class, structure, inductive,
    axiom, constant, variable, namespace, section, noncomputable, protected,
    private, abbrev, example, open, attribute, local, mutual, by, where,
    extends, deriving, end, import, prelude, theory, with, without, using,
    match, if, then, else, fun, have, show, from, let, in, do, begin, calc},
  % Types and Type constructors
  morekeywords=[2]{Type, Prop, Sort, Nat, Int, Bool, String, Char, List,
    Option, Unit, Prod, Sum, Sigma, Subtype, Set, Scheme, CommRingCat,
    AffineScheme, Opens, IsAffine, IsAffineOpen, Spec, Category, Functor,
    Iso, IsIso, CompactSpace, IsCompact, IsOpenImmersion, Equiv, Hom, LocallyRingedSpace,
    TopCat, SheafedSpace, PresheafedSpace, PrimeSpectrum, StructureSheaf, Localization,
    IsLocalRing, Subring, LocalPredicate, PrelocalPredicate},
  % Tactics (if they appear)
  morekeywords=[3]{simp, rfl, exact, apply, intro, cases, induction, refl,
    constructor, assumption, contradiction, trivial, sorry, admit, rw,
    convert, infer_instance, ext, rintro, obtain, refine, dsimp, rcases, grind},
  % Sensitive
  sensitive=true,
  % Comments
  morecomment=[l]{--},
  morecomment=[n]{/-}{-/},
  % Strings
  morestring=[b]",
  % Style
  keywordstyle=[1]\color{leanKeyword}\bfseries,
  keywordstyle=[2]\color{leanType}\bfseries,
  keywordstyle=[3]\color{leanDefinition}\itshape,
  commentstyle=\color{leanComment}\itshape,
  stringstyle=\color{leanString},
  % Highlight attributes
  moredelim=[is][\color{leanAttribute}]{@[}{]},
  moredelim=[is][\color{leanAttribute}]{\#[}{]},
}

\lstset{
  language=Lean,
  basicstyle=\ttfamily\small,
  backgroundcolor=\color{leanBackground},
  breaklines=true,
  frame=single,
  framerule=0.5pt,
  rulecolor=\color{gray!30},
  numbers=left,
  numberstyle=\tiny\color{gray},
  numbersep=5pt,
  showstringspaces=false,
  prebreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
  breakindent=25pt,
  captionpos=b,
  xleftmargin=10pt,
  framexleftmargin=10pt,
  % Unicode replacements for mathematical symbols
  literate={Œì}{{$\Gamma$}}1
           {‚ä§}{{$\top$}}1
           {‚ü∂}{{$\to$}}2
           {‚âÖ}{{$\cong$}}1
           {‚äÜ}{{$\subseteq$}}1
           {‚®Ü}{{$\bigsqcup$}}1
           {‚àà}{{$\in$}}1
           {‚àÉ}{{$\exists$}}1
           {‚àß}{{$\land$}}1
           {‚Åª¬π·µÅ}{{$^{-1}U$}}3
           {‚Åª¬π}{{$^{-1}$}}2
           {‚â´}{{>>}}1
           {‚â§}{{$\leq$}}1
           {·µí·µñ}{{$^{op}$}}2
           {‚•§}{{$\Rightarrow$}}2
           {‚âå}{{$\simeq$}}1
           {‚ãô}{{$\ggg$}}1
           {‚àÄ}{{$\forall$}}1
           {‚Üë}{{$\uparrow$}}1
           {ùí∞}{{$\mathcal{U}$}}1
           {ùüô}{{$\mathbb{1}$}}1
           {''·µÅ}{{''U}}2
           {‚â™‚â´}{{$\ll\gg$}}2
           {Œπ}{{$\iota$}}1
           {‚Üí}{{$\to$}}1
           {·µÅ}{{U}}1
           {:=}{{$\mathrel{:=}$}}2
           {√ó}{{$\times$}}1
           {‚ß∏}{{$/\!/$}}1
           {‚Üî}{{$\leftrightarrow$}}1
           {‚ü®}{{$\langle$}}1
           {‚ü©}{{$\rangle$}}1
           {Œ±}{{$\alpha$}}1
           {Œ≤}{{$\beta$}}1
           {Œ≥}{{$\gamma$}}1
           {Œ¥}{{$\delta$}}1
           {Œµ}{{$\varepsilon$}}1
           {Œª}{{$\lambda$}}1
           {Œº}{{$\mu$}}1
           {œÉ}{{$\sigma$}}1
           {œÑ}{{$\tau$}}1
           {œÜ}{{$\varphi$}}1
           {œà}{{$\psi$}}1
           {œâ}{{$\omega$}}1
           {‚àû}{{$\infty$}}1
           {‚àÇ}{{$\partial$}}1
           {‚àá}{{$\nabla$}}1
           {‚äì}{{$\sqcap$}}1
           {ùî≠}{{$\mathfrak{p}$}}1
           {ùîÆ}{{$\mathfrak{q}$}}1
           {ùí™}{{$\mathcal{O}$}}1
}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{instance}{Instance}

\title{The Structure Sheaf in Mathlib4\\
\large A Companion to \texttt{StructureSheaf.lean}}
\author{}
\date{}

\begin{document}
\maketitle

\section{Introduction}

This document provides a natural language companion to the \texttt{StructureSheaf.lean} file in Mathlib4. The file constructs the structure sheaf on the prime spectrum $\mathrm{Spec}(R)$ of a commutative ring $R$, which is fundamental to the definition of affine schemes.

The structure sheaf provides the "functions" on the prime spectrum, generalizing the notion of rational functions on algebraic varieties. The key insight is that sections over an open set should be functions that are "locally fractions" - that is, they can be locally expressed as ratios $a/f$ where $a, f \in R$ and $f$ does not vanish on the open set.

\section{Theoretical Background}

Following Hartshorne's approach, for an open set $U \subseteq \mathrm{Spec}(A)$, we define $\mathcal{O}(U)$ to be the set of functions $s : U \to \bigsqcup_{\mathfrak{p} \in U} A_\mathfrak{p}$, such that:
\begin{itemize}
\item $s(\mathfrak{p}) \in A_\mathfrak{p}$ for each $\mathfrak{p}$
\item $s$ is locally a quotient of elements of $A$
\end{itemize}

The modern approach uses dependent functions $\Pi x : U, \text{Localizations } R \, x$ instead of functions into disjoint unions.

\section{Basic Definitions}

\subsection{Localizations at Points}

\begin{lstlisting}
def PrimeSpectrum.Top : TopCat := TopCat.of (PrimeSpectrum R)

def Localizations (P : PrimeSpectrum.Top R) : Type u :=
  Localization.AtPrime P.asIdeal

instance commRingLocalizations (P : PrimeSpectrum.Top R) : CommRing <| Localizations R P
instance localRingLocalizations (P : PrimeSpectrum.Top R) : IsLocalRing <| Localizations R P
\end{lstlisting}

\textbf{Natural Language:} For each prime ideal $\mathfrak{p} \in \mathrm{Spec}(R)$, we have the localization $R_\mathfrak{p}$, which is a local ring. These localizations will serve as the "stalks" of our sheaf.

\section{The Fraction Condition}

\subsection{Basic Fraction Property}

\begin{lstlisting}
def IsFraction {U : Opens (PrimeSpectrum.Top R)} (f : ‚àÄ x : U, Localizations R x) : Prop :=
  ‚àÉ r s : R, ‚àÄ x : U, s ‚àâ x.1.asIdeal ‚àß f x * algebraMap _ _ s = algebraMap _ _ r
\end{lstlisting}

\textbf{Natural Language:} A dependent function $f$ is a fraction if there exist global elements $r, s \in R$ such that at every point $x \in U$, we have $s \notin x$ (so $s$ is invertible in $R_x$) and $f(x) = r/s$ in the localization $R_x$.

\subsection{Characterization as Fractions}

\begin{lstlisting}
theorem IsFraction.eq_mk' {U : Opens (PrimeSpectrum.Top R)} {f : ‚àÄ x : U, Localizations R x}
    (hf : IsFraction f) :
    ‚àÉ r s : R,
      ‚àÄ x : U,
        ‚àÉ hs : s ‚àâ x.1.asIdeal,
          f x =
            IsLocalization.mk' (Localization.AtPrime _) r
              (‚ü®s, hs‚ü© : (x : PrimeSpectrum.Top R).asIdeal.primeCompl)
\end{lstlisting}

\textbf{Natural Language:} If a function is a fraction, then it can be explicitly written as $r/s$ using the localization construction at each point, where $s$ is in the prime complement of each prime ideal.

\subsection{Prelocal Property}

\begin{lstlisting}
def isFractionPrelocal : PrelocalPredicate (Localizations R) where
  pred {_} f := IsFraction f
  res := by rintro V U i f ‚ü®r, s, w‚ü©; exact ‚ü®r, s, fun x => w (i x)‚ü©
\end{lstlisting}

\textbf{Natural Language:} The property of being a fraction is "prelocal": if it holds on an open set $U$, it also holds on any open subset $V \subseteq U$. This is because the same fraction representation works on smaller open sets.

\section{Local Fractions}

\subsection{The Local Fraction Condition}

\begin{lstlisting}
def isLocallyFraction : LocalPredicate (Localizations R) :=
  (isFractionPrelocal R).sheafify

theorem isLocallyFraction_pred {U : Opens (PrimeSpectrum.Top R)} (f : ‚àÄ x : U, Localizations R x) :
    (isLocallyFraction R).pred f =
      ‚àÄ x : U,
        ‚àÉ (V : _) (_ : x.1 ‚àà V) (i : V ‚ü∂ U),
          ‚àÉ r s : R,
            ‚àÄ y : V, s ‚àâ y.1.asIdeal ‚àß f (i y : U) * algebraMap _ _ s = algebraMap _ _ r
\end{lstlisting}

\textbf{Natural Language:} A function is locally a fraction if around every point, there exists a neighborhood where the function can be expressed as a single fraction $r/s$. This is the sheafification of the basic fraction condition.

\subsection{Subring Structure}

\begin{lstlisting}
def sectionsSubring (U : (Opens (PrimeSpectrum.Top R))·µí·µñ) :
    Subring (‚àÄ x : U.unop, Localizations R x) where
  carrier := { f | (isLocallyFraction R).pred f }
  zero_mem' := -- proof that 0 is locally a fraction
  one_mem' := -- proof that 1 is locally a fraction
  add_mem' := -- proof that sum of local fractions is local fraction
  mul_mem' := -- proof that product of local fractions is local fraction
  neg_mem' := -- proof that negative of local fraction is local fraction
\end{lstlisting}

\textbf{Natural Language:} The functions that are locally fractions form a subring of all dependent functions. This gives us the ring structure we need for our structure sheaf.

\section{The Structure Sheaf Construction}

\subsection{Sheaf in Types}

\begin{lstlisting}
def structureSheafInType : Sheaf (Type u) (PrimeSpectrum.Top R) :=
  subsheafToTypes (isLocallyFraction R)
\end{lstlisting}

\textbf{Natural Language:} First, we construct the structure sheaf as a sheaf of types, where sections are locally constant fractions.

\subsection{Ring Structure on Sections}

\begin{lstlisting}
instance commRingStructureSheafInTypeObj (U : (Opens (PrimeSpectrum.Top R))·µí·µñ) :
    CommRing ((structureSheafInType R).1.obj U) :=
  (sectionsSubring R U).toCommRing

def structurePresheafInCommRing : Presheaf CommRingCat (PrimeSpectrum.Top R) where
  obj U := CommRingCat.of ((structureSheafInType R).1.obj U)
  map i := CommRingCat.ofHom ((structureSheafInType R).1.map i)
\end{lstlisting}

\textbf{Natural Language:} The sections carry a natural commutative ring structure inherited from the subring of locally constant fractions. This gives us a presheaf of commutative rings.

\subsection{The Main Structure Sheaf}

\begin{lstlisting}
def Spec.structureSheaf : Sheaf CommRingCat (PrimeSpectrum.Top R) :=
  ‚ü®structurePresheafInCommRing R, isSheaf_of_isSheaf_comp _ (structureSheafInType R).2‚ü©
\end{lstlisting}

\textbf{Natural Language:} The structure sheaf on $\mathrm{Spec}(R)$ is the sheaf of commutative rings whose sections over an open set are functions that are locally expressible as fractions of elements from $R$.

\section{Basic Operations}

\subsection{Constant Functions}

\begin{lstlisting}
def const (f g : R) (U : Opens (PrimeSpectrum.Top R))
    (hu : ‚àÄ x : PrimeSpectrum.Top R, x ‚àà U ‚Üí g ‚àâ x.asIdeal) :
    (structureSheaf R).1.obj (op U) :=
  ‚ü®fun x : U => algebraMap _ _ f * (algebraMap _ _ g)‚Åª¬π, ‚ü®f, g, fun x => ‚ü®hu x.1 x.2, by simp‚ü©‚ü©‚ü©
\end{lstlisting}

\textbf{Natural Language:} For elements $f, g \in R$ where $g$ doesn't vanish on an open set $U$, we can form the constant function $f/g$ as a section over $U$. This gives us a way to embed ring elements into the structure sheaf.

\subsection{Properties of Constants}

\begin{lstlisting}
theorem const_zero (f : R) (U hu) : const R 0 f U hu = 0
theorem const_one (U) : (const R 1 1 U fun _ _ => Submonoid.one_mem _) = 1
theorem const_add (f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ : R) (U hu‚ÇÅ hu‚ÇÇ) :
    const R f‚ÇÅ g‚ÇÅ U hu‚ÇÅ + const R f‚ÇÇ g‚ÇÇ U hu‚ÇÇ = const R (f‚ÇÅ * g‚ÇÇ + f‚ÇÇ * g‚ÇÅ) (g‚ÇÅ * g‚ÇÇ) U (by ...)
theorem const_mul (f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ : R) (U hu‚ÇÅ hu‚ÇÇ) :
    const R f‚ÇÅ g‚ÇÅ U hu‚ÇÅ * const R f‚ÇÇ g‚ÇÇ U hu‚ÇÇ = const R (f‚ÇÅ * f‚ÇÇ) (g‚ÇÅ * g‚ÇÇ) U (by ...)
\end{lstlisting}

\textbf{Natural Language:} Constant functions behave exactly as expected: zero gives the zero section, the constant $1/1$ gives the unit section, and arithmetic operations on constants correspond to the appropriate fraction arithmetic.

\section{Global Sections and Ring Homomorphisms}

\subsection{From Ring to Opens}

\begin{lstlisting}
def toOpen (U : Opens (PrimeSpectrum.Top R)) :
    CommRingCat.of R ‚ü∂ (structureSheaf R).1.obj (op U) :=
  ‚ü®fun f => const R f 1 U fun _ _ => Submonoid.one_mem _, by ring‚ü©
\end{lstlisting}

\textbf{Natural Language:} Any ring element $f \in R$ can be viewed as a constant function $f/1$ on any open set. This gives us a canonical ring homomorphism from $R$ to the sections over any open set.

\subsection{From Ring to Stalks}

\begin{lstlisting}
def toStalk (x : PrimeSpectrum.Top R) : CommRingCat.of R ‚ü∂ (structureSheaf R).presheaf.stalk x :=
  toOpen R ‚ä§ ‚â´ (structureSheaf R).presheaf.germ ‚ü®x, trivial‚ü©
\end{lstlisting}

\textbf{Natural Language:} We can also map ring elements to any stalk by first viewing them as global sections, then taking the germ at the desired point.

\subsection{Relationship Between Opens and Stalks}

\begin{lstlisting}
theorem toOpen_germ (U : Opens (PrimeSpectrum.Top R)) (x : PrimeSpectrum.Top R) (hx : x ‚àà U) :
    toOpen R U ‚â´ (structureSheaf R).presheaf.germ ‚ü®x, hx‚ü© = toStalk R x

theorem germ_toOpen (U : Opens (PrimeSpectrum.Top R)) (x : PrimeSpectrum.Top R) (hx : x ‚àà U) (f : R) :
    (structureSheaf R).presheaf.germ ‚ü®x, hx‚ü© (toOpen R U f) = toStalk R x f
\end{lstlisting}

\textbf{Natural Language:} Taking the germ of a constant section is the same as mapping the element directly to the stalk. This shows the consistency of our constructions.

\section{Key Isomorphisms}

\subsection{Stalk Isomorphism}

\begin{lstlisting}
def stalkIso (x : PrimeSpectrum.Top R) :
    (structureSheaf R).presheaf.stalk x ‚âÖ CommRingCat.of (Localization.AtPrime x.asIdeal) :=
  { hom := stalkToFiberRingHom R x
    inv := localizationToStalk R x
    hom_inv_id := -- proof
    inv_hom_id := -- proof }
\end{lstlisting}

\textbf{Natural Language:} The stalk of the structure sheaf at a prime $\mathfrak{p}$ is canonically isomorphic to the localization $R_\mathfrak{p}$. This is the fundamental connection between the geometric (sheaf) and algebraic (localization) perspectives.

\subsection{Basic Open Isomorphism}

\begin{lstlisting}
def basicOpenIso (f : R) :
    (structureSheaf R).1.obj (op (PrimeSpectrum.basicOpen f)) ‚âÖ CommRingCat.of (Localization.Away f) :=
  { hom := toBasicOpen R f
    inv := -- inverse map
    hom_inv_id := -- proof
    inv_hom_id := -- proof }
\end{lstlisting}

\textbf{Natural Language:} The sections of the structure sheaf over a basic open $D(f) = \{x : f \notin x\}$ are canonically isomorphic to the localization $R[f^{-1}]$. This shows that basic opens correspond exactly to localizations.

\subsection{Global Sections Isomorphism}

\begin{lstlisting}
def globalSectionsIso : CommRingCat.of R ‚âÖ (structureSheaf R).1.obj (op ‚ä§) :=
  { hom := toOpen R ‚ä§
    inv := -- inverse map
    hom_inv_id := -- proof
    inv_hom_id := -- proof }
\end{lstlisting}

\textbf{Natural Language:} The global sections of the structure sheaf are canonically isomorphic to the original ring $R$. This establishes that $\Gamma(\mathrm{Spec}(R), \mathcal{O}) \cong R$, a fundamental property of affine schemes.

\section{Unit and Invertibility Properties}

\subsection{Units in Basic Opens}

\begin{lstlisting}
theorem isUnit_to_basicOpen_self (f : R) : IsUnit (toOpen R (PrimeSpectrum.basicOpen f) f) :=
\end{lstlisting}

\textbf{Natural Language:} An element $f \in R$ becomes a unit when viewed as a section over the basic open $D(f)$. This makes geometric sense: $f$ is invertible exactly where it doesn't vanish.

\subsection{Units in Stalks}

\begin{lstlisting}
theorem isUnit_toStalk (x : PrimeSpectrum.Top R) (f : x.asIdeal.primeCompl) :
    IsUnit (toStalk R x f) :=
\end{lstlisting}

\textbf{Natural Language:} Elements that are not in a prime ideal $\mathfrak{p}$ become units in the stalk at $\mathfrak{p}$. This reflects the definition of localization.

\section{Localization Maps and Compatibility}

\subsection{Localization to Stalk}

\begin{lstlisting}
def localizationToStalk (x : PrimeSpectrum.Top R) :
    CommRingCat.of (Localization.AtPrime x.asIdeal) ‚ü∂ (structureSheaf R).presheaf.stalk x :=

theorem localizationToStalk_of (x : PrimeSpectrum.Top R) (f : R) :
    localizationToStalk R x (algebraMap _ _ f) = toStalk R x f

theorem localizationToStalk_mk' (x : PrimeSpectrum.Top R) (f : R) (s : x.asIdeal.primeCompl) :
    localizationToStalk R x (IsLocalization.mk' _ f s) =
    (structureSheaf R).presheaf.germ ‚ü®x, trivial‚ü© (toOpen R ‚ä§ f) *
    (toStalk R x s)‚Åª¬π
\end{lstlisting}

\textbf{Natural Language:} There are canonical maps from localizations to stalks that respect the algebraic operations. The map sends $f/s$ to the germ of $f$ times the inverse of the germ of $s$.

\subsection{Open to Localization}

\begin{lstlisting}
def openToLocalization (U : Opens (PrimeSpectrum.Top R)) (x : PrimeSpectrum.Top R) (hx : x ‚àà U) :
    (structureSheaf R).1.obj (op U) ‚ü∂ CommRingCat.of (Localization.AtPrime x.asIdeal) :=
  (structureSheaf R).presheaf.germ ‚ü®x, hx‚ü© ‚â´ stalkToFiberRingHom R x
\end{lstlisting}

\textbf{Natural Language:} Sections over an open set containing a point can be evaluated at that point, giving an element of the localization at that point's prime ideal.

\section{Computational Aspects}

\subsection{Explicit Section Formulas}

\begin{lstlisting}
theorem toOpen_apply (U : Opens (PrimeSpectrum.Top R)) (f : R) (x : U) :
    (toOpen R U f).val x = algebraMap _ _ f

theorem res_apply (U V : Opens (PrimeSpectrum.Top R)) (i : V ‚ü∂ U)
    (s : (structureSheaf R).1.obj (op U)) (x : V) :
    ((structureSheaf R).1.map i.op s).val x = s.val (i x)
\end{lstlisting}

\textbf{Natural Language:} The explicit formulas show how sections behave: constant sections have the expected values, and restriction simply composes with the inclusion map.

\section{Advanced Properties}

\subsection{Existence of Local Representations}

\begin{lstlisting}
theorem exists_const (U) (s : (structureSheaf R).1.obj (op U)) (x : PrimeSpectrum.Top R)
    (hx : x ‚àà U) : ‚àÉ (V) (_ : x ‚àà V) (i : V ‚ü∂ U) (f g : R)
    (_ : ‚àÄ y ‚àà V, g ‚àâ y.asIdeal),
    (structureSheaf R).1.map i.op s = const R f g V _
\end{lstlisting}

\textbf{Natural Language:} Every section can be locally represented as a constant fraction. This is the key property that characterizes the structure sheaf: all sections are locally fractions.

\subsection{Uniqueness and Extension}

The structure sheaf construction ensures that:
\begin{itemize}
\item Sections are determined by their local behavior
\item Local data can be glued to global sections when compatible
\item The resulting sheaf has the correct stalks (localizations)
\item Basic opens correspond to localizations
\end{itemize}

\section{Conclusion}

The structure sheaf construction provides the algebraic foundation for defining schemes. Key insights:

\begin{enumerate}
\item \textbf{Local-Global Principle}: Functions are defined locally as fractions and glued globally
\item \textbf{Stalks are Localizations}: The local rings of the sheaf are exactly the algebraic localizations
\item \textbf{Basic Opens and Localization}: Geometric opens correspond to algebraic localizations
\item \textbf{Global Sections Recovery}: The original ring is recovered as global sections
\end{enumerate}

This construction bridges the gap between commutative algebra (rings, localizations, prime ideals) and algebraic geometry (spaces, sheaves, local rings), providing the foundation for the theory of schemes in Mathlib4.

\end{document}
