\documentclass{article}
\input{unicode_preamble}

\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{geometry}
\geometry{margin=1in}

% Define colors for Lean syntax highlighting
\definecolor{leanKeyword}{RGB}{0, 0, 255}       % Blue for keywords
\definecolor{leanType}{RGB}{139, 0, 139}        % Dark magenta for types
\definecolor{leanString}{RGB}{0, 128, 0}        % Green for strings
\definecolor{leanComment}{RGB}{128, 128, 128}   % Gray for comments
\definecolor{leanDefinition}{RGB}{255, 140, 0}  % Dark orange for definitions

% Configure listings for Lean
\lstdefinelanguage{Lean}{
    keywords={def, theorem, lemma, example, axiom, class, instance, inductive, structure,
              variable, namespace, open, import, export, section, end, if, then, else,
              match, with, fun, let, have, show, by, where, do, return, for, in,
              variable, universe, noncomputable, partial, mutual, protected, private,
              unsafe, opaque, @[simp], @[inline], @[reducible], @[irreducible],
              attribute, set_option, notation, infixl, infixr, prefix, postfix,
              scoped, local, macro, syntax, elab, deriving, extends, mk},
    morekeys={Type, Prop, Sort, Nat, Int, Real, Bool, true, false, Unit, 
              List, Array, Option, some, none, Sum, Prod, Sigma, Pi,
              and, or, not, iff, exists, forall},
    sensitive=true,
    morecomment=[l]{--},
    morecomment=[s]{/-}{-/},
    morestring=[b]",
    morestring=[b]',
}

\lstset{
    language=Lean,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{leanKeyword}\bfseries,
    commentstyle=\color{leanComment}\itshape,
    stringstyle=\color{leanString},
    numberstyle=\tiny\color{gray},
    numbers=left,
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{white},
    frame=single,
    rulecolor=\color{black!30},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=2,
    captionpos=b,
    showstringspaces=false,
    literate={
        {Œ±}{{$\alpha$}}1 {Œ≤}{{$\beta$}}1 {Œ≥}{{$\gamma$}}1 {Œ¥}{{$\delta$}}1
        {Œµ}{{$\varepsilon$}}1 {Œ∂}{{$\zeta$}}1 {Œ∑}{{$\eta$}}1 {Œ∏}{{$\theta$}}1
        {Œπ}{{$\iota$}}1 {Œ∫}{{$\kappa$}}1 {Œª}{{$\lambda$}}1 {Œº}{{$\mu$}}1
        {ŒΩ}{{$\nu$}}1 {Œæ}{{$\xi$}}1 {œÄ}{{$\pi$}}1 {œÅ}{{$\rho$}}1
        {œÉ}{{$\sigma$}}1 {œÑ}{{$\tau$}}1 {œÜ}{{$\varphi$}}1 {œá}{{$\chi$}}1
        {œà}{{$\psi$}}1 {œâ}{{$\omega$}}1 {Œì}{{$\Gamma$}}1 {Œî}{{$\Delta$}}1
        {Œò}{{$\Theta$}}1 {Œõ}{{$\Lambda$}}1 {Œ£}{{$\Sigma$}}1 {Œ¶}{{$\Phi$}}1
        {Œ®}{{$\Psi$}}1 {Œ©}{{$\Omega$}}1
        {‚Üí}{{$\rightarrow$}}2 {‚Üê}{{$\leftarrow$}}2 {‚ü∂}{{$\longrightarrow$}}2
        {‚Üî}{{$\leftrightarrow$}}2 {‚ü∑}{{$\longleftrightarrow$}}2
        {‚â§}{{$\leq$}}1 {‚â•}{{$\geq$}}1 {‚â†}{{$\neq$}}1 {‚âà}{{$\approx$}}1
        {‚â°}{{$\equiv$}}1 {‚âÖ}{{$\cong$}}1 {‚âÉ}{{$\simeq$}}1
        {‚àà}{{$\in$}}1 {‚àâ}{{$\notin$}}1 {‚äÜ}{{$\subseteq$}}1 {‚äá}{{$\supseteq$}}1
        {‚äÇ}{{$\subset$}}1 {‚äÉ}{{$\supset$}}1 {‚à™}{{$\cup$}}1 {‚à©}{{$\cap$}}1
        {‚àÖ}{{$\emptyset$}}1 {‚àû}{{$\infty$}}1 {‚àÇ}{{$\partial$}}1
        {‚àÄ}{{$\forall$}}1 {‚àÉ}{{$\exists$}}1 {‚àß}{{$\land$}}1 {‚à®}{{$\lor$}}1
        {¬¨}{{$\neg$}}1 {‚ä§}{{$\top$}}1 {‚ä•}{{$\bot$}}1
        {√ó}{{$\times$}}1 {¬∑}{{$\cdot$}}1 {‚àò}{{$\circ$}}1
        {‚äó}{{$\otimes$}}1 {‚äï}{{$\oplus$}}1 {‚äô}{{$\odot$}}1
        {‚àë}{{$\sum$}}1 {‚àè}{{$\prod$}}1 {‚à´}{{$\int$}}1
        {‚ÇÄ}{{$_0$}}1 {‚ÇÅ}{{$_1$}}1 {‚ÇÇ}{{$_2$}}1 {‚ÇÉ}{{$_3$}}1 {‚ÇÑ}{{$_4$}}1
        {‚ÇÖ}{{$_5$}}1 {‚ÇÜ}{{$_6$}}1 {‚Çá}{{$_7$}}1 {‚Çà}{{$_8$}}1 {‚Çâ}{{$_9$}}1
        {‚Çô}{{$_n$}}1 {‚Çò}{{$_m$}}1 {·µ¢}{{$_i$}}1 {‚±º}{{$_j$}}1
        {‚Å∞}{{$^0$}}1 {¬π}{{$^1$}}1 {¬≤}{{$^2$}}1 {¬≥}{{$^3$}}1 {‚Å¥}{{$^4$}}1
        {‚Åµ}{{$^5$}}1 {‚Å∂}{{$^6$}}1 {‚Å∑}{{$^7$}}1 {‚Å∏}{{$^8$}}1 {‚Åπ}{{$^9$}}1
        {‚Åø}{{$^n$}}1 {·µê}{{$^m$}}1 {‚Å±}{{$^i$}}1
        {‚Ñï}{{$\mathbb{N}$}}1 {‚Ñ§}{{$\mathbb{Z}$}}1 {‚Ñö}{{$\mathbb{Q}$}}1
        {‚Ñù}{{$\mathbb{R}$}}1 {‚ÑÇ}{{$\mathbb{C}$}}1
        {ùí∞}{{$\mathcal{U}$}}1 {ùí±}{{$\mathcal{V}$}}1 {ùí≤}{{$\mathcal{W}$}}1
        {ùí≥}{{$\mathcal{X}$}}1 {ùí¥}{{$\mathcal{Y}$}}1 {ùíµ}{{$\mathcal{Z}$}}1
        {ùî∏}{{$\mathbb{A}$}}1 {ùîπ}{{$\mathbb{B}$}}1 {ùîΩ}{{$\mathbb{F}$}}1
        {ùïÇ}{{$\mathbb{K}$}}1 {ùïä}{{$\mathbb{S}$}}1
        {‚ü®}{{$\langle$}}1 {‚ü©}{{$\rangle$}}1 {‚åä}{{$\lfloor$}}1 {‚åã}{{$\rfloor$}}1
        {‚åà}{{$\lceil$}}1 {‚åâ}{{$\rceil$}}1
        {‚Åª¬π}{{$^{-1}$}}2 {‚ñ∏}{{$\triangleright$}}1
    }
}

\title{Lean 4 Code: ValuativeCriterion}
\author{Mathlib4}
\date{\today}

\begin{document}
\maketitle

\section{Source Code}

The following is the Lean 4 source code from \texttt{ValuativeCriterion.lean}:

\begin{lstlisting}[language=Lean, caption={ValuativeCriterion.lean}]
/-
Copyright (c) 2024 Andrew Yang, Qi Ge, Christian Merten. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang, Qi Ge, Christian Merten
-/
import Mathlib.AlgebraicGeometry.Morphisms.Immersion
import Mathlib.AlgebraicGeometry.Morphisms.Proper
import Mathlib.RingTheory.RingHom.Injective
import Mathlib.RingTheory.Valuation.LocalSubring

/-!
# Valuative criterion

## Main results

- `AlgebraicGeometry.UniversallyClosed.eq_valuativeCriterion`:
  A morphism is universally closed if and only if
  it is quasi-compact and satisfies the existence part of the valuative criterion.
- `AlgebraicGeometry.IsSeparated.eq_valuativeCriterion`:
  A morphism is separated if and only if
  it is quasi-separated and satisfies the uniqueness part of the valuative criterion.
- `AlgebraicGeometry.IsProper.eq_valuativeCriterion`:
  A morphism is proper if and only if
  it is qcqs and of fintite type and satisfies the valuative criterion.

## Future projects
Show that it suffices to check discrete valuation rings when the base is Noetherian.

-/

open CategoryTheory CategoryTheory.Limits

namespace AlgebraicGeometry

universe u

/--
A valuative commutative square over a morphism `f : X ‚ü∂ Y` is a square
```
Spec K ‚ü∂ Y
  |       |
  ‚Üì       ‚Üì
Spec R ‚ü∂ X
```
where `R` is a valuation ring, and `K` is its ring of fractions.

We are interested in finding lifts `Spec R ‚ü∂ Y` of this diagram.
-/
structure ValuativeCommSq {X Y : Scheme.{u}} (f : X ‚ü∂ Y) where
  /-- The valuation ring of a valuative commutative square. -/
  R : Type u
  [commRing : CommRing R]
  [domain : IsDomain R]
  [valuationRing : ValuationRing R]
  /-- The field of fractions of a valuative commutative square. -/
  K : Type u
  [field : Field K]
  [algebra : Algebra R K]
  [isFractionRing : IsFractionRing R K]
  /-- The top map in a valuative commutative map. -/
  (i‚ÇÅ : Spec(K) ‚ü∂ X)
  /-- The bottom map in a valuative commutative map. -/
  (i‚ÇÇ : Spec(R) ‚ü∂ Y)
  (commSq : CommSq i‚ÇÅ (Spec.map (CommRingCat.ofHom (algebraMap R K))) f i‚ÇÇ)

namespace ValuativeCommSq

attribute [instance] commRing domain valuationRing field algebra isFractionRing

end ValuativeCommSq

/-- A morphism `f : X ‚ü∂ Y` satisfies the existence part of the valuative criterion if
every valuative commutative square over `f` has (at least) a lift. -/
def ValuativeCriterion.Existence : MorphismProperty Scheme :=
  fun _ _ f ‚Ü¶ ‚àÄ S : ValuativeCommSq f, S.commSq.HasLift

/-- A morphism `f : X ‚ü∂ Y` satisfies the uniqueness part of the valuative criterion if
every valuative commutative square over `f` has at most one lift. -/
def ValuativeCriterion.Uniqueness : MorphismProperty Scheme :=
  fun _ _ f ‚Ü¶ ‚àÄ S : ValuativeCommSq f, Subsingleton S.commSq.LiftStruct

/-- A morphism `f : X ‚ü∂ Y` satisfies the valuative criterion if
every valuative commutative square over `f` has a unique lift. -/
def ValuativeCriterion : MorphismProperty Scheme :=
  fun _ _ f ‚Ü¶ ‚àÄ S : ValuativeCommSq f, Nonempty (Unique (S.commSq.LiftStruct))

variable {X Y : Scheme.{u}} (f : X ‚ü∂ Y)

lemma ValuativeCriterion.iff {f : X ‚ü∂ Y} :
    ValuativeCriterion f ‚Üî Existence f ‚àß Uniqueness f := by
  change (‚àÄ _, _) ‚Üî (‚àÄ _, _) ‚àß (‚àÄ _, _)
  simp_rw [‚Üê forall_and, unique_iff_subsingleton_and_nonempty, and_comm, CommSq.HasLift.iff]

lemma ValuativeCriterion.eq :
    ValuativeCriterion = Existence ‚äì Uniqueness := by
  ext X Y f
  exact iff

lemma ValuativeCriterion.existence {f : X ‚ü∂ Y} (h : ValuativeCriterion f) :
    ValuativeCriterion.Existence f := (iff.mp h).1

lemma ValuativeCriterion.uniqueness {f : X ‚ü∂ Y} (h : ValuativeCriterion f) :
    ValuativeCriterion.Uniqueness f := (iff.mp h).2

namespace ValuativeCriterion.Existence

open IsLocalRing

@[stacks 01KE]
lemma specializingMap (H : ValuativeCriterion.Existence f) :
    SpecializingMap f.base := by
  intro x' y h
  let stalk_y_to_residue_x' : Y.presheaf.stalk y ‚ü∂ X.residueField x' :=
    Y.presheaf.stalkSpecializes h ‚â´ f.stalkMap x' ‚â´ X.residue x'
  obtain ‚ü®A, hA, hA_local‚ü© := exists_factor_valuationRing stalk_y_to_residue_x'.hom
  let stalk_y_to_A : Y.presheaf.stalk y ‚ü∂ .of A :=
    CommRingCat.ofHom (stalk_y_to_residue_x'.hom.codRestrict _ hA)
  have w : X.fromSpecResidueField x' ‚â´ f =
      Spec.map (CommRingCat.ofHom (algebraMap A (X.residueField x'))) ‚â´
        Spec.map stalk_y_to_A ‚â´ Y.fromSpecStalk y := by
    rw [Scheme.fromSpecResidueField, Category.assoc, ‚Üê Scheme.Spec_map_stalkMap_fromSpecStalk,
      ‚Üê Scheme.Spec_map_stalkSpecializes_fromSpecStalk h]
    simp_rw [‚Üê Spec.map_comp_assoc]
    rfl
  obtain ‚ü®l, hl‚ÇÅ, hl‚ÇÇ‚ü© := (H { R := A, K := X.residueField x', commSq := ‚ü®w‚ü©, .. }).exists_lift
  dsimp only at hl‚ÇÅ hl‚ÇÇ
  refine ‚ü®l.base (closedPoint A), ?_, ?_‚ü©
  ¬∑ simp_rw [‚Üê Scheme.fromSpecResidueField_apply x' (closedPoint (X.residueField x')), ‚Üê hl‚ÇÅ]
    exact (specializes_closedPoint _).map l.base.hom.2
  ¬∑ rw [‚Üê Scheme.comp_base_apply, hl‚ÇÇ]
    simp only [Scheme.comp_coeBase, TopCat.coe_comp, Function.comp_apply]
    have : (Spec.map stalk_y_to_A).base (closedPoint A) = closedPoint (Y.presheaf.stalk y) :=
      comap_closedPoint (S := A) (stalk_y_to_residue_x'.hom.codRestrict A.toSubring hA)
    rw [this, Y.fromSpecStalk_closedPoint]

instance {R S : CommRingCat} (e : R ‚âÖ S) : IsLocalHom e.hom.hom :=
  isLocalHom_of_isIso _

lemma of_specializingMap (H : (topologically @SpecializingMap).universally f) :
    ValuativeCriterion.Existence f := by
  rintro ‚ü®R, K, i‚ÇÅ, i‚ÇÇ, ‚ü®w‚ü©‚ü©
  haveI : IsDomain (CommRingCat.of R) := ‚Äπ_‚Ä∫
  haveI : ValuationRing (CommRingCat.of R) := ‚Äπ_‚Ä∫
  letI : Field (CommRingCat.of K) := ‚Äπ_‚Ä∫
  replace H := H (pullback.snd i‚ÇÇ f) i‚ÇÇ (pullback.fst i‚ÇÇ f) (.of_hasPullback i‚ÇÇ f)
  let lft := pullback.lift (Spec.map (CommRingCat.ofHom (algebraMap R K))) i‚ÇÅ w.symm
  obtain ‚ü®x, h‚ÇÅ, h‚ÇÇ‚ü© := @H (lft.base (closedPoint _)) _ (specializes_closedPoint (R := R) _)
  let e : CommRingCat.of R ‚âÖ Spec(R).presheaf.stalk ((pullback.fst i‚ÇÇ f).base x) :=
    (stalkClosedPointIso (.of R)).symm ‚â™‚â´
      Spec(R).presheaf.stalkCongr (.of_eq h‚ÇÇ.symm)
  let Œ± := e.hom ‚â´ (pullback.fst i‚ÇÇ f).stalkMap x
  have : IsLocalHom e.hom.hom := isLocalHom_of_isIso e.hom
  have : IsLocalHom Œ±.hom := inferInstanceAs
    (IsLocalHom (((pullback.fst i‚ÇÇ f).stalkMap x).hom.comp e.hom.hom))
  let Œ≤ := (pullback i‚ÇÇ f).presheaf.stalkSpecializes h‚ÇÅ ‚â´ Scheme.stalkClosedPointTo lft
  have hŒ±Œ≤ : Œ± ‚â´ Œ≤ = CommRingCat.ofHom (algebraMap R K) := by
    simp only [CommRingCat.coe_of, Iso.trans_hom, Iso.symm_hom, TopCat.Presheaf.stalkCongr_hom,
      Category.assoc, Œ±, e, Œ≤, stalkClosedPointIso_inv, StructureSheaf.toStalk]
    change (Scheme.ŒìSpecIso (.of R)).inv ‚â´ Spec(R).presheaf.germ _ _ _ ‚â´ _ = _
    simp only [TopCat.Presheaf.germ_stalkSpecializes_assoc, Scheme.stalkMap_germ_assoc]
    -- `map_top` introduces defeq problems, according to `check_compositions`.
    -- This is probably the cause of the `erw` needed below.
    simp only [TopologicalSpace.Opens.map_top]
    rw [Scheme.germ_stalkClosedPointTo lft ‚ä§ trivial]
    erw [‚Üê Scheme.comp_app_assoc lft (pullback.fst i‚ÇÇ f)]
    rw [pullback.lift_fst]
    simp
  have hbij := (bijective_rangeRestrict_comp_of_valuationRing (R := R) (K := K) Œ±.hom Œ≤.hom
    (CommRingCat.hom_ext_iff.mp hŒ±Œ≤))
  let œÜ : (pullback i‚ÇÇ f).presheaf.stalk x ‚ü∂ CommRingCat.of R := CommRingCat.ofHom <|
    (RingEquiv.ofBijective _ hbij).symm.toRingHom.comp Œ≤.hom.rangeRestrict
  have hŒ±œÜ : Œ± ‚â´ œÜ = ùüô _ := by ext x; exact (RingEquiv.ofBijective _ hbij).symm_apply_apply x
  have hŒ±œÜ' : (pullback.fst i‚ÇÇ f).stalkMap x ‚â´ œÜ = e.inv := by
    rw [‚Üê cancel_epi e.hom, ‚Üê Category.assoc, hŒ±œÜ, e.hom_inv_id]
  have hœÜŒ≤ : œÜ ‚â´ CommRingCat.ofHom (algebraMap R K) = Œ≤ :=
    hŒ±Œ≤ ‚ñ∏ CommRingCat.hom_ext (RingHom.ext fun x ‚Ü¶ congr_arg Subtype.val
      ((RingEquiv.ofBijective _ hbij).apply_symm_apply (Œ≤.hom.rangeRestrict x)))
  refine ‚ü®‚ü®‚ü®Spec.map ((pullback.snd i‚ÇÇ f).stalkMap x ‚â´ œÜ) ‚â´ X.fromSpecStalk _, ?_, ?_‚ü©‚ü©‚ü©
  ¬∑ simp only [‚Üê Spec.map_comp_assoc, Category.assoc, hœÜŒ≤]
    simp only [Spec.map_comp, Category.assoc, Scheme.Spec_map_stalkMap_fromSpecStalk,
      Scheme.Spec_map_stalkSpecializes_fromSpecStalk_assoc, Œ≤]
    -- This next line only fires as `rw`, not `simp`:
    rw [Scheme.Spec_stalkClosedPointTo_fromSpecStalk_assoc]
    simp [lft]
  ¬∑ simp only [Spec.map_comp, Category.assoc, Scheme.Spec_map_stalkMap_fromSpecStalk,
      ‚Üê pullback.condition]
    rw [‚Üê Scheme.Spec_map_stalkMap_fromSpecStalk_assoc, ‚Üê Spec.map_comp_assoc, hŒ±œÜ']
    simp only [Iso.trans_inv, TopCat.Presheaf.stalkCongr_inv, Iso.symm_inv, Spec.map_comp,
      Category.assoc, Scheme.Spec_map_stalkSpecializes_fromSpecStalk_assoc, e]
    rw [‚Üê Spec_stalkClosedPointIso, ‚Üê Spec.map_comp_assoc,
      Iso.inv_hom_id, Spec.map_id, Category.id_comp]

instance stableUnderBaseChange : ValuativeCriterion.Existence.IsStableUnderBaseChange := by
  constructor
  intro Y' X X' Y  Y'_to_Y f X'_to_X f' hP hf commSq
  let commSq' : ValuativeCommSq f :=
  { R := commSq.R
    K := commSq.K
    i‚ÇÅ := commSq.i‚ÇÅ ‚â´ X'_to_X
    i‚ÇÇ := commSq.i‚ÇÇ ‚â´ Y'_to_Y
    commSq := ‚ü®by simp only [Category.assoc, hP.w, reassoc_of% commSq.commSq.w]‚ü© }
  obtain ‚ü®l‚ÇÄ, hl‚ÇÅ, hl‚ÇÇ‚ü© := (hf commSq').exists_lift
  refine ‚ü®‚ü®‚ü®hP.lift l‚ÇÄ commSq.i‚ÇÇ (by simp_all only [commSq']), ?_, hP.lift_snd _ _ _‚ü©‚ü©‚ü©
  apply hP.hom_ext
  ¬∑ simpa
  ¬∑ simp only [Category.assoc]
    rw [hP.lift_snd]
    rw [commSq.commSq.w]

@[stacks 01KE]
protected lemma eq :
    ValuativeCriterion.Existence = (topologically @SpecializingMap).universally := by
  ext
  constructor
  ¬∑ intro _
    apply MorphismProperty.universally_mono
    ¬∑ apply specializingMap
    ¬∑ rwa [MorphismProperty.IsStableUnderBaseChange.universally_eq]
  ¬∑ apply of_specializingMap

end ValuativeCriterion.Existence

/-- The **valuative criterion** for universally closed morphisms. -/
@[stacks 01KF]
lemma UniversallyClosed.eq_valuativeCriterion :
    @UniversallyClosed = ValuativeCriterion.Existence ‚äì @QuasiCompact := by
  rw [universallyClosed_eq_universallySpecializing, ValuativeCriterion.Existence.eq]

/-- The **valuative criterion** for universally closed morphisms. -/
@[stacks 01KF]
lemma UniversallyClosed.of_valuativeCriterion [QuasiCompact f]
    (hf : ValuativeCriterion.Existence f) : UniversallyClosed f := by
  rw [eq_valuativeCriterion]
  exact ‚ü®hf, ‚Äπ_‚Ä∫‚ü©

section Uniqueness

/-- The **valuative criterion** for separated morphisms. -/
@[stacks 01L0]
lemma IsSeparated.of_valuativeCriterion [QuasiSeparated f]
    (hf : ValuativeCriterion.Uniqueness f) : IsSeparated f where
  diagonal_isClosedImmersion := by
    suffices h : ValuativeCriterion.Existence (pullback.diagonal f) by
      have : QuasiCompact (pullback.diagonal f) :=
        AlgebraicGeometry.QuasiSeparated.diagonalQuasiCompact
      apply IsClosedImmersion.of_isPreimmersion
      apply IsClosedMap.isClosed_range
      apply (topologically @IsClosedMap).universally_le
      exact (UniversallyClosed.of_valuativeCriterion (pullback.diagonal f) h).out
    intro S
    have hc : CommSq S.i‚ÇÅ (Spec.map (CommRingCat.ofHom (algebraMap S.R S.K)))
        f (S.i‚ÇÇ ‚â´ pullback.fst f f ‚â´ f) := ‚ü®by simp [‚Üê S.commSq.w_assoc]‚ü©
    let S' : ValuativeCommSq f := ‚ü®S.R, S.K, S.i‚ÇÅ, S.i‚ÇÇ ‚â´ pullback.fst f f ‚â´ f, hc‚ü©
    have : Subsingleton S'.commSq.LiftStruct := hf S'
    let S'l‚ÇÅ : S'.commSq.LiftStruct := ‚ü®S.i‚ÇÇ ‚â´ pullback.fst f f,
      by simp [S', ‚Üê S.commSq.w_assoc], by simp [S']‚ü©
    let S'l‚ÇÇ : S'.commSq.LiftStruct := ‚ü®S.i‚ÇÇ ‚â´ pullback.snd f f,
      by simp [S', ‚Üê S.commSq.w_assoc], by simp [S', pullback.condition]‚ü©
    have h‚ÇÅ‚ÇÇ : S'l‚ÇÅ = S'l‚ÇÇ := Subsingleton.elim _ _
    constructor
    constructor
    refine ‚ü®S.i‚ÇÇ ‚â´ pullback.fst _ _, ?_, ?_‚ü©
    ¬∑ simp [‚Üê S.commSq.w_assoc]
    ¬∑ simp
      apply IsPullback.hom_ext (IsPullback.of_hasPullback _ _)
      ¬∑ simp
      ¬∑ simp only [Category.assoc, pullback.diagonal_snd, Category.comp_id]
        exact congrArg CommSq.LiftStruct.l h‚ÇÅ‚ÇÇ

@[stacks 01KZ]
lemma IsSeparated.valuativeCriterion [IsSeparated f] : ValuativeCriterion.Uniqueness f := by
  intro S
  constructor
  rintro ‚ü®l‚ÇÅ, hl‚ÇÅ, hl‚ÇÅ'‚ü© ‚ü®l‚ÇÇ, hl‚ÇÇ, hl‚ÇÇ'‚ü©
  ext : 1
  dsimp at *
  have h := hl‚ÇÅ'.trans hl‚ÇÇ'.symm
  let Z := pullback (pullback.diagonal f) (pullback.lift l‚ÇÅ l‚ÇÇ h)
  let g : Z ‚ü∂ Spec(S.R) := pullback.snd _ _
  have : IsClosedImmersion g := MorphismProperty.pullback_snd _ _ inferInstance
  have hZ : IsAffine Z := by
    rw [@HasAffineProperty.iff_of_isAffine @IsClosedImmersion] at this
    exact this.left
  suffices IsIso g by
    rw [‚Üê cancel_epi g]
    conv_lhs => rw [‚Üê pullback.lift_fst l‚ÇÅ l‚ÇÇ h, ‚Üê pullback.condition_assoc]
    conv_rhs => rw [‚Üê pullback.lift_snd l‚ÇÅ l‚ÇÇ h, ‚Üê pullback.condition_assoc]
    simp
  suffices h : Function.Bijective (g.appTop) by
    refine (HasAffineProperty.iff_of_isAffine (P := MorphismProperty.isomorphisms Scheme)).mpr ?_
    exact ‚ü®hZ, (ConcreteCategory.isIso_iff_bijective _).mpr h‚ü©
  constructor
  ¬∑ let l : Spec(S.K) ‚ü∂ Z :=
      pullback.lift S.i‚ÇÅ (Spec.map (CommRingCat.ofHom (algebraMap S.R S.K))) (by
        apply IsPullback.hom_ext (IsPullback.of_hasPullback _ _)
        ¬∑ simpa using hl‚ÇÅ.symm
        ¬∑ simpa using hl‚ÇÇ.symm)
    have hg : l ‚â´ g = Spec.map (CommRingCat.ofHom (algebraMap S.R S.K)) :=
      pullback.lift_snd _ _ _
    have : Function.Injective ((l ‚â´ g).appTop) := by
      rw [hg]
      let e := arrowIsoŒìSpecOfIsAffine (CommRingCat.ofHom <| algebraMap S.R S.K)
      let P : MorphismProperty CommRingCat :=
        RingHom.toMorphismProperty <| fun f ‚Ü¶ Function.Injective f
      have : (RingHom.toMorphismProperty <| fun f ‚Ü¶ Function.Injective f).RespectsIso :=
        RingHom.toMorphismProperty_respectsIso_iff.mp RingHom.injective_respectsIso
      change P _
      rw [‚Üê MorphismProperty.arrow_mk_iso_iff (P := P) e]
      exact FaithfulSMul.algebraMap_injective S.R S.K
    rw [Scheme.comp_appTop] at this
    exact Function.Injective.of_comp this
  ¬∑ rw [@HasAffineProperty.iff_of_isAffine @IsClosedImmersion] at this
    exact this.right

/-- The **valuative criterion** for separated morphisms. -/
lemma IsSeparated.eq_valuativeCriterion :
    @IsSeparated = ValuativeCriterion.Uniqueness ‚äì @QuasiSeparated := by
  ext X Y f
  exact ‚ü®fun _ ‚Ü¶ ‚ü®IsSeparated.valuativeCriterion f, inferInstance‚ü©,
    fun ‚ü®H, _‚ü© ‚Ü¶ .of_valuativeCriterion f H‚ü©

end Uniqueness

/-- The **valuative criterion** for proper morphisms. -/
@[stacks 0BX5]
lemma IsProper.eq_valuativeCriterion :
    @IsProper = ValuativeCriterion ‚äì @QuasiCompact ‚äì @QuasiSeparated ‚äì @LocallyOfFiniteType := by
  rw [isProper_eq, IsSeparated.eq_valuativeCriterion, ValuativeCriterion.eq,
    UniversallyClosed.eq_valuativeCriterion]
  simp_rw [inf_assoc]
  ext X Y f
  change _ ‚àß _ ‚àß _ ‚àß _ ‚àß _ ‚Üî _ ‚àß _ ‚àß _ ‚àß _ ‚àß _
  tauto

/-- The **valuative criterion** for proper morphisms. -/
@[stacks 0BX5]
lemma IsProper.of_valuativeCriterion [QuasiCompact f] [QuasiSeparated f] [LocallyOfFiniteType f]
    (H : ValuativeCriterion f) : IsProper f := by
  rw [eq_valuativeCriterion]
  exact ‚ü®‚ü®‚ü®‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü©, ‚Äπ_‚Ä∫‚ü©, ‚Äπ_‚Ä∫‚ü©

end AlgebraicGeometry

\end{lstlisting}

\end{document}
